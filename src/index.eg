
require:
   "./repl" ->
      Repl
   "./editor" ->
      Editor
   "./util" ->
      DOM, repr as _repr

provide:
   Repl, Editor, DOM, _repr as repr


;; Hack to avoid reloading these modules...
toNeuter = {
   "npm:earlgrey-runtime/5"
   "npm:earlgrey-runtime/6"
   "npm:earlgrey-runtime/lib"
   "npm:earlgrey-runtime@0.0.4/5"
   "npm:earlgrey-runtime@0.0.4/6"
   "npm:earlgrey-runtime@0.0.4/lib"
}
if global.System:
   global.System._loader.modules &: object with toNeuter each x ->
      {x, {name = x, module = {=}}}






;; require:
;;    "earlgrey/5" as eg
;;    "earlgrey/lib5/expand" ->
;;       topscope
;;    "./repl" ->
;;       Repl
;;    "./util" ->
;;       DOM, repr as _repr
;;    "./doc" ->
;;       Cards, Nav
;;    "./editor" ->
;;       Editor
;;    codemirror as CodeMirror

;; provide:
;;    eg
;;    egrepl, egeditor
;;    Repl, DOM, repr
;;    Cards, Nav

;; globals:
;;    System


;; ;; Hack to avoid reloading these modules...
;; toNeuter = {
;;    "npm:earlgrey-runtime/5"
;;    "npm:earlgrey-runtime/6"
;;    "npm:earlgrey-runtime/lib"
;;    "npm:earlgrey-runtime@0.0.4/5"
;;    "npm:earlgrey-runtime@0.0.4/6"
;;    "npm:earlgrey-runtime@0.0.4/lib"
;; }
;; System._loader.modules &: object with toNeuter each x ->
;;    {x, {name = x, module = {=}}}


;; let repr = _repr

;; egrepl{box, interactive, inputline, code} =

;;    globvar = "$eg$global"
;;    gene = eg.Generator{true, globvar}
;;    _ev = eg.evaluator with {
;;       globvar = globvar
;;       global = global
;;       filename = "<repl>"
;;       showname = "<repl>"
;;       cwd = "<repl>"
;;    }

;;    evopts = {to5 = true, noboil = true}
;;    ev{text} =
;;       let code = gene.generate{eg.Source{text, "<repl>"}, evopts}
;;       _ev{code}
;;    evi{text} =
;;       let code = gene.generateInteractive{eg.Source{text, "<repl>"}, evopts}
;;       _ev{code}

;;    repl = Repl with {
;;       elements = {
;;          box = box
;;          target = interactive
;;          inputline = inputline
;;          textarea = code
;;       }
;;       async! eval{text} =
;;          try:
;;             res = await evi{text}
;;             ;; print {res, typeof{res}, repr{res}}
;;             #success{res}
;;          catch e:
;;             #failure{e}
;;    }

;;    glob = global

;;    repl.setenv{values} =
;;       items{values} each {name, value} ->
;;          gene.env.bind{topscope, name, #variable{name}}
;;          glob[name] = value
;;       undefined

;;    repl.setenv with {
;;       $io = {}
;;       $currenti = -1
;;       System = System
;;       DOM = DOM
;;    }

;;    repl.eval with S[
;;       globals:
;;          window, document, JSON

;;       wait = promisify with {d, f} -> setTimeout.call{null, f, d}

;;       _load{match url} =
;;          R".js$"? ->
;;             new Promise with {resolve, reject} ->
;;                document.getElementsByTagName{"head"}[0].appendChild with
;;                   DOM with script %
;;                      async = true
;;                      type = "text/javascript"
;;                      src = url
;;                      onload{} = resolve{undefined}
;;          R".css$"? ->
;;             document.getElementsByTagName{"head"}[0].appendChild with
;;                DOM with link %
;;                   rel = "stylesheet"
;;                   type = "text/css"
;;                   href = url
;;             undefined
;;          else ->
;;             throw E.unknown_resource_type{url}

;;       macro $out{match}:
;;          do:
;;             globals: $currenti
;;          #void{} ->
;;             `$io[^=$currenti]`
;;          expr ->
;;             `$io[^=$currenti][^expr]`

;;       macro print{expr}:
;;          ;; out = @mark{`$out`}
;;          ;; `t = ^expr, $out.log{t}, t`
;;          `t = ^expr, $io[$currenti].log{t}, t`

;;       macro __require{#data{expr}}:
;;          ```
;;          t = ^expr
;;          name = match t:
;;             RegExp{"^raw:"}? x -> x.slice{4}
;;             RegExp{":"}? x -> x
;;             x -> "npm:" + x
;;          await System.import{name}
;;          ```

;;       macro load{url}:
;;          `await _load{^url}`

;;    ]

;;    repl


;; egeditor{target, success, failure, live = true} =

;;    gene = eg.Generator{true}

;;    ed = Editor with
;;       target

;;       {=}

;;       {text} ->
;;          try:
;;             #success{gene.evaluate{eg.Source{text, "<ed>"}}}
;;          catch e:
;;             #failure{e}

;;       success, failure, live

;;    ed.eval{text} = gene.evaluate{eg.Source{text, "<ed>"}}
;;    ed
