
require:
   "earlgrey" as eg
   "earlgrey/lib/expand" ->
      topscope
   "./repl" ->
      Repl
   "./util" ->
      DOM, repr as _repr
   "./doc" ->
      Cards, Nav
   "./editor" ->
      Editor
   codemirror as CodeMirror

provide:
   eg
   egrepl, egeditor
   Repl, DOM, repr
   Cards, Nav

let repr = _repr

globals:
   System


egrepl{box, interactive, inputline, code} =

   globvar = "$eg$global"
   gene = eg.Generator{true, globvar}
   _ev = eg.evaluator with {
      globvar = globvar
      global = global
      filename = "<repl>"
      showname = "<repl>"
      cwd = "<repl>"
   }

   evopts = {to5 = true, noboil = true}
   ev{text} =
      let code = gene.generate{eg.Source{text, "<repl>"}, evopts}
      _ev{code}
   evi{text} =
      let code = gene.generateInteractive{eg.Source{text, "<repl>"}, evopts}
      _ev{code}

   repl = Repl with

      box, interactive, inputline, code

      async: {text} ->
         try:
            ;; code = gene.generateInteractive{eg.Source{text, "<repl>"}, opts}
            ;; res = await ev{code}
            #success{await evi{text}}

            ;; #success{await gene.evaluateInteractive{eg.Source{text, "<repl>"}, opts}} where
            ;;    opts = {to5 = true}
         catch e:
            #failure{e}

      {...} with
         ;; smart parentheses
         "'('"{cm} =
            cur = cm.getCursor{}
            tok = cm.getTokenAt{cur}
            situation =
               predicate! stringtype{x} =
                  x in {.string, .interpolated, .quote}
               match tok.type:
                  stringtype? when tok.end > cur.ch ->
                     .string
                  stringtype? when R"\"$"? tok.string or R"^\."? tok.string ->
                     .id
                  stringtype? ->
                     .string
                  .operator or .wordop or .open or .punctuation or === null ->
                     .op
                  else ->
                     .id
            match situation:
               .string -> CodeMirror.Pass
               .op -> cm.replaceSelection{"["}
               .id -> cm.replaceSelection{"{"}

         "')'"{cm} =
            cur = cm.getCursor{}
            tok = cm.getTokenAt{cur}
            situation =
               match tok.type:
                  .string when tok.end > cur.ch ->
                     .string
                  .string when R"\"$"? tok.string or R"^\."? tok.string ->
                     .other
                  .string ->
                     .string
                  else ->
                     .other
            match situation:
               .string -> CodeMirror.Pass
               else ->
                  match tok.state.nest:
                     {*, {match, *}} ->
                        "{" -> cm.replaceSelection{"}"}
                        "[" -> cm.replaceSelection{"]"}
                        else -> CodeMirror.Pass
                     else ->
                        CodeMirror.Pass

   ;; glob = gene.evaluate{eg.Source{s, "<repl>"}} where
   ;;    s = "globals: [global, window], if{typeof{global} === .undefined, window, global}"
   ;; ;; glob = ev with
   ;; ;;    "globals: [global, window], if{typeof{global} === .undefined, window, global}"
   ;; console.log{glob}
   glob = global

   repl.setenv{values} =
      items{values} each {name, value} ->
         gene.env.bind{topscope, name, #variable{name}}
         glob[name] = value
      undefined

   repl.setenv{{...}} with
      $io = {}
      $currenti = -1
      System = System
      DOM = DOM

   repl.eval with S[
      globals:
         window, document, JSON

      ;; Annoyingly, this runs regardless of the value of global._egruntime_installed
      ;; This will replace globals, so ENodes before the import will fail instance checks.
      ;; So we just... preempt the damage.
      chain System:
         @import{"npm:earlgrey-runtime/6"}
         @then with {_} -> pass
         @catch with {e} -> pass

      wait = promisify with {d, f} -> setTimeout.call{null, f, d}

      _load{match url} =
         R".js$"? ->
            new Promise with {resolve, reject} ->
               document.getElementsByTagName{"head"}[0].appendChild with
                  DOM with script %
                     async = true
                     type = "text/javascript"
                     src = url
                     onload{} = resolve{undefined}
         R".css$"? ->
            document.getElementsByTagName{"head"}[0].appendChild with
               DOM with link %
                  rel = "stylesheet"
                  type = "text/css"
                  href = url
            undefined
         else ->
            throw E.unknown_resource_type{url}

      macro $out{match}:
         do:
            globals: $currenti
         #void{} ->
            `$io[^=$currenti]`
         expr ->
            `$io[^=$currenti][^expr]`

      macro print{expr}:
         ;; out = @mark{`$out`}
         ;; `t = ^expr, $out.log{t}, t`
         `t = ^expr, $io[$currenti].log{t}, t`

      macro __require{#data{expr}}:
         ```
         t = ^expr
         name = match t:
            RegExp{"^raw:"}? x -> x.slice{4}
            RegExp{":"}? x -> x
            x -> "npm:" + x
         await System.import{name}
         ```

      macro load{url}:
         `await _load{^url}`

   ]

   repl


egeditor{target, success, failure, live = true} =

   gene = eg.Generator{true}

   ed = Editor with
      target

      {...} with
         ;; smart parentheses
         "'('"{cm} =
            cur = cm.getCursor{}
            tok = cm.getTokenAt{cur}
            situation =
               match tok.type:
                  .string when tok.end > cur.ch ->
                     .string
                  .string when R"\"$"? tok.string or R"^\."? tok.string ->
                     .id
                  .string ->
                     .string
                  .operator or .wordop or .open or .punctuation or === null ->
                     .op
                  else ->
                     .id
            match situation:
               .string -> CodeMirror.Pass
               .op -> cm.replaceSelection{"["}
               .id -> cm.replaceSelection{"{"}

         "')'"{cm} =
            cur = cm.getCursor{}
            tok = cm.getTokenAt{cur}
            situation =
               match tok.type:
                  .string when tok.end > cur.ch ->
                     .string
                  .string when R"\"$"? tok.string or R"^\."? tok.string ->
                     .other
                  .string ->
                     .string
                  else ->
                     .other
            match situation:
               .string -> CodeMirror.Pass
               else ->
                  match tok.state.nest:
                     {*, {match, *}} ->
                        "{" -> cm.replaceSelection{"}"}
                        "[" -> cm.replaceSelection{"]"}
                        else -> CodeMirror.Pass
                     else ->
                        CodeMirror.Pass

      {text} ->
         try:
            #success{gene.evaluate{eg.Source{text, "<ed>"}}}
         catch e:
            #failure{e}

      success, failure, live

   ed.eval{text} = gene.evaluate{eg.Source{text, "<ed>"}}
   ed
