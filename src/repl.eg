
require:
   "./cards" -> make_cards
   "./kb" as kb
   "earl-grey/earl-grey" as eg
   "earl-grey/util" ->
      GenSym
   "earl-grey/location" ->
      Location, highlight_locations
      format_error
   "earl-grey/lex" ->
      tokenize
   "earl-grey/parse" ->
      parse

provide:
   Repl, kb.Interactor as Interactor, parse, tokenize, eg.Source as Source
   make_cards{repr} as make_cards

globals:
   document, window, alert, jQuery, setTimeout, Showdown




gensym = GenSym{"io_"}

;; macro [%]{context, scope, {=> env}, #data{descr, contents}}:

;;    tag = .div
;;    cls = {}
;;    id = null
;;    kv = '{=}

;;    parse{match whole} =
;;       #void{} -> null
;;       #symbol{s} ->
;;          tag = s
;;       #value{x} ->
;;          cls.push with x
;;       '[. ^[#symbol{x} or #value{x}]] ->
;;          cls.push with x
;;       '[# ^[#symbol{x} or #value{x}]] ->
;;          id = #value{x}
;;       '[^_ = ^_] ->
;;          kv.push with whole
;;       #send{expr, rest} ->
;;          parse{expr}, parse{rest}
;;       #multi{*args} or #data{*args} ->
;;          args each arg -> parse{arg}

;;    parse{descr}

;;    if id:
;;       kv.push with '["id" = ^id]
;;    if cls.length:
;;       kv.push with '["className" = ^=cls.join{" "}]

;;    contents ?=
;;       #void{} -> #array{}
;;       #multi{*args} ->
;;          xs = {}
;;          args each
;;             pair and '[^k = ^v] ->
;;                kv.push with pair
;;             splice and '[** ^_] ->
;;                kv.push with splice
;;             other ->
;;                xs.push with other
;;          #array{*xs}
;;       pair and '[^k = ^v] ->
;;          kv.push with pair
;;          #array{}
;;       x -> x

;;    '[^env.convert{'create_node}]{^=tag, ^kv, ^contents}


create_node{tag, kv, contents} =
   node = document.createElement{tag}
   items{kv} each {k, v} ->
      node[k] = v
   [Array! contents] each
      String? s ->
         node.appendChild{document.createTextNode{s}}
      other ->
         node.appendChild{other}
   node


make_dom{match, default_tag = "div"} =

   String? s ->
      document.createTextNode{s}

   Array? args ->
      node = document.createElement{"span"}
      args each arg ->
         node.appendChild{make_dom{arg, default_tag}}
      node

   Node? {=> tags, => props, => children} ->
      var tag = default_tag
      classes = {}
      tags each
         R"^\\.(.*)"! {_, name} ->
            classes.push{name}
         other ->
            tag = other

      node = document.createElement{tag}
      if classes.length:
         node.className = classes.join{" "}
      items{props} each {k, v} ->
         node[k] = v

      match tag:
         .raw ->
            children each
               String? s ->
                  node.innerHTML = s
         other ->
            children each c ->
               node.appendChild{make_dom{c, default_tag}}

      node

   ;; Node? {=> classes, => children} ->
   ;;    var tag = default_tag
   ;;    _classes = {}
   ;;    var id = null
   ;;    kv = {}
   ;;    sub = {}
   ;;    classes each
   ;;       #assoc{k, v} ->
   ;;          kv.push with {k, v}
   ;;       #assoc{k} ->
   ;;          kv.push with {k, undefined}
   ;;       R'[start, "+", {*any}]! {_, m} ->
   ;;          tag = m
   ;;       R'[start, "#", {*any}]! {_, m} ->
   ;;          id = m
   ;;       String? s ->
   ;;          _classes.push with s

   ;;    node = document.createElement{tag}
   ;;    if id:
   ;;       node.id = id
   ;;    if _classes.length:
   ;;       node.className = _classes.join{" "}
   ;;    kv each {k, v} ->
   ;;       node[k] = v

   ;;    match tag:
   ;;       .raw ->
   ;;          children each
   ;;             String? s ->
   ;;                node.innerHTML = s
   ;;       other ->
   ;;          children each c ->
   ;;             node.appendChild{make_dom{c, default_tag}}

   ;;    node

   other ->
      make_dom{String! other}

mktable{x, recur = repr} =
   its = match x:
      Array? -> x
      other -> items{x}
   if its.length:
      then:
         table.object %
            its each {k, v} ->
               tr %
                  th % recur{k, repr}
                  td % recur{v, repr}
      else:
         .object.empty %

repr{match x, Function? recur = repr} =
   === true -> .special.true % "true"
   === false -> .special.false % "false"
   null? -> .special.nil % "null"
   undefined? -> .special.nil % "undefined"
   Number? -> .num % String{x}
   "" -> .str.empty %
   String? -> .str % x
   Array? {} -> .sequence.empty %
   Array? entries ->
      .sequence % [entries each x -> recur{x, repr}]
   Node? n ->
      n
   when x["::repr"] ->
      x["::repr"]{recur}
   when Object.getPrototypeOf{x} === Object.prototype ->
      mktable{x}
   when x.constructor and x.constructor["::egclass"] ->
      .instance %
         .classname % x.constructor["::name"]
         mktable{x}
   when x["::egclass"] ->
      .class %
         .classname % "Class " + x["::name"]
         mktable{x.prototype}
   Function? f ->
      .function % if{f.name, f.name, "<anonymous>"}
   other ->
      .unknown % other.toString{}


goto_end{elem} =
   let range = document.createRange{}
   range.selectNodeContents{elem}
   range.collapse{false}
   selection = window.getSelection{}
   selection.removeAllRanges{}
   selection.addRange{range}

insert_before_caret{text} =
   node = match text:
      String? -> document.createTextNode{text}
      other -> other
   sel = window.getSelection{}
   if sel.rangeCount:
      var range = sel.getRangeAt{0}
      using range:
         @collapse{false}
         @insertNode{node}
      range = range.cloneRange{}
      using range:
         @selectNodeContents{node}
         @collapse{false}
      sel.removeAllRanges{}
      sel.addRange{range}


Error.prototype["::repr"] = {} ->
   format_error{this}


class Repl:

   constructor{box, target, input, evaluator} =

      @url = "<repl>"
      @gen = eg.Generator{true}
      @evaluator = evaluator

      @box = box
      @target = target
      @input = input
      @multiline = false

      @interactor = kb.Interactor{{=}}
      @set_multiline{false}
      @interactor.install{@input}

      @cursor = 0
      @history = {""}

   sink{} =
      jQuery{@box}.scrollTop{@box.scrollHeight}

   add_to_history{text} =
      hl = @history.length
      if [text !== "" and not [hl > 1 and @history[hl - 2] == text]]:
         ;; Only add to history if the command was nonempty
         ;; and we're not repeating the same command
         @history[hl - 1] = text
         @history.push{""}
      @cursor = @history.length - 1

   submit{} =
      @set_multiline{false}
      text = @input.textContent
      @process{text}
      @input.innerHTML = ""
      @sink{}

   begin_multiline{} =
      @set_multiline{true}
      ;; @input.innerHTML = @input.innerHTML + "\n   "
      goto_end{@input}
      insert_before_caret{"\n   "}
      @sink{}

   set_multiline{x} = match x:
      do:
         previous{} =
            if [@cursor > 0]:
               @input.textContent = @history[-- @cursor]
               goto_end{@input}
               @sink{}
         next{} =
            if [@cursor < @history.length - 1]:
               @input.textContent = @history[++ @cursor]
               goto_end{@input}
               @sink{}
         common = {
            "C-l"{} =
               jQuery{@target}.empty{}
            "S-Enter"{} =
               @submit{}
         }

      === false ->
         jQuery{@input}.removeClass{.multiline}
         @interactor.set_bindings with common & {
            "C-m"{} =
               @set_multiline{true}
               .break
            "C-Enter"{} =
               @begin_multiline{}
               .break
            Enter{} =
               match @input.textContent:
                  R"(=|->|%|:|with|where|each)$"? ->
                     @begin_multiline{}
                  other ->
                     @submit{}
            Up = previous
            Down = next
         }

      === true ->
         jQuery{@input}.addClass{.multiline}
         @interactor.set_bindings with common & {
            "C-m"{} =
               @set_multiline{false}
               .break
            "C-Enter"{} =
               @submit{}
            Enter{} =
               insert_before_caret{"\n"}
               @sink{}
            Tab{} =
               insert_before_caret{"   "}
         }

   generate{text} =
      @gen.generate{eg.Source{text, @url}}

   eval{text} =
      [gen{} !! e -> handle{e}] where
         gen{} =
            g = @generate{text}
            #success{@evaluator{g}}
         handle{e} =
            #failure{e}

   process{text, display_in = true} =
      @add_to_history{text}
      real_text = text ;; "\n" + text + "\n"
      node = make_dom with
         .io %
            if display_in:
               then:
                  .[in] %
                     .inbanner %
                     .entry % text or " "
               else:
                  ""
            match @eval{real_text}:
               when text.trim{} === "" ->
                  ""
               #success{undefined?} ->
                  ""
               #success{Node? n} ->
                  .display %
                     .displaybanner %
                     .result % n
               #success{value} ->
                  .out %
                     .outbanner %
                     .result % .eg % repr{value}
               #failure{error} ->
                  .err %
                     .errbanner %
                     .result % .eg % repr{error}

      name = gensym{}
      node.id = name

      @target.appendChild{node}

      collapse{e} =
         e.stopPropagation{}
         at_top = @box.scrollTop + jQuery{@box}.height{} == @box.scrollHeight
         jQuery{this}.toggleClass{"collapsed"}
         if at_top:
            jQuery{@box}.scrollTop{@box.scrollHeight}

      on{sel} =
         jQuery{"#" + name + " " + sel}

      on{".sequence"}.addClass{"complex"}
      on{".object"}.addClass{"complex"}
      
      on{".complex"}.click{collapse}
      on{".complex .complex .complex"}.addClass{.collapsed}

      on{".error_args.syntax"}.addClass{.collapsed}.click{collapse}
      on{".traceback"}.addClass{.collapsed}.click{collapse}


