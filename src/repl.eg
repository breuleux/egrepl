
require:
   codemirror as CodeMirror
   "codemirror/addon/runmode/runmode"
   "./earlmode"
   "./util" ->
      DOM, dom_node_clear, repr as _repr
      GenSym, format_error, wait
   jquery as jQuery

provide:
   Outputter, Repl, repr

globals:
   document, window, alert, setTimeout
   Element

let repr = _repr


gensym = GenSym{"io_"}


Error.prototype["::repr"] = {} ->
   format_error{this}

;; Element.prototype["::repr"] = {} ->
;;    % String{this}
;;    ;; this



class Outputter:

   constructor{@elem} =
      pass

   log{*data} =
      @elem.appendChild with
         DOM with div %
            data each match x ->
               Element? or ENode? -> x
               else -> .eg % repr{x}
      undefined


class Repl:

   constructor{opts} =
      ;; Required fields
      {elements => {box => @box, target => @target
                    textarea => @textarea}
       eval => @eval} = opts

      ;; Optional fields
      @inputline = opts.elements.inputline
      @keymap = opts.elements.keymap or {=}

      @keymap or= {=}
      @setup_cm{@textarea}
      @cursor = 0
      @history = {""}

   setup_cm{textarea} =

      @cm = CodeMirror.fromTextArea with
         textarea
         {
            indentUnit = 3
            viewportMargin = 1/0
            theme = .repl
            ;; lineNumbers = true
         }

      @cm.addKeyMap{km & @keymap} where km = {

         Enter{match cm} =
            do:
               e = cm.lineCount{} - 1
            when cm.getCursor{}.line < e ->
               CodeMirror.Pass
            else ->
               state = cm.getStateAfter{e}
               match:
                  when state.mode !== .code
                       \ or state.nest.length > 1
                       \ or R"lowprio|op"? state.previous
                       \ or [state.nest[0][2] > 0 and not R"^\s*$"? cm.getLine{e}] ->
                     CodeMirror.Pass
                  else ->
                     @submit{}

         "Shift-Enter" = "newlineAndIndent"

         "Ctrl-Enter"{cm} =
            @submit{}

         "Ctrl-Up"{cm} =
            if [@cursor > 0]:
               @cm.setValue with @history[-- @cursor]
               @cm.setCursor{@cm.lineCount{}, 0}
               @sink{}

         "Ctrl-Down"{cm} =
            if [@cursor < @history.length - 1]:
               @cm.setValue with @history[++ @cursor]
               @cm.setCursor{0, @cm.getLine{0}.length}
               @sink{}

         Up{match cm} =
            when @cursor > 0 and @cm.getCursor{}.line === 0 ->
               @cm.setValue with @history[-- @cursor]
               @cm.setCursor{@cm.lineCount{}, 0}
               @sink{}
            else ->
               CodeMirror.Pass

         Down{match cm} =
            when [@cursor < @history.length - 1 and
                  \ @cm.getCursor{}.line === [@cm.lineCount{} - 1]] ->
               @cm.setValue with @history[++ @cursor]
               @cm.setCursor{0, @cm.getLine{0}.length}
               @sink{}
            else ->
               CodeMirror.Pass

         Tab = "indentAuto"

         "Ctrl-L"{_} =
            jQuery{@target}.empty{}

         "Ctrl-A" = "goLineStart"
         "Ctrl-E" = "goLineEnd"
         "Ctrl-K" = "killLine"
      }

      @cm.setOption{"mode", "earl-grey"}
      @cm.setSize{.auto, .auto}

   sink{} =
      setTimeout{f, 0} where f{} =
         jQuery{@box}.scrollTop{@box.scrollHeight}

   add_to_history{text} =
      hl = @history.length
      if [text !== "" and not [hl > 1 and @history[hl - 2] == text]]:
         ;; Only add to history if the command was nonempty
         ;; and we're not repeating the same command
         @history[hl - 1] = text
         @history.push{""}
      @cursor = @history.length - 1

   async! submit{} =
      text = @cm.getValue{}
      if @inputline:
         jQuery{@inputline}.hide{}
      var done = false
      try:
         await any {
            f{} where async! f{} =
               res = await @process_all{text, true, true}
               done = true
               res
            wait{10000}
         }
         ;; await @process_all{text, true, true}
      catch e:
         done = true
         console.log with e.stack
      if not done:
         window.$io[window.$currenti].log with 
            "Request is taking too much time... executing in the background..."
      if @inputline:
         jQuery{@inputline}.show{}
      @cm.setValue{""}
      @cm.focus{}

   highlight{text} =
      hl = {}
      CodeMirror.runMode{text or " ", "earl-grey"} with {text, style} ->
         hl.push with
            if style:
               then: span ^[".cm-" + style] % text
               else: span % text
      div".cm-s-repl" %
         hl

   async! process_all{text, display_in = true, sink = false} =
      text.split{"\n===\n"} each part ->
         await @process{part, display_in, sink}

   async! process{text, display_in = true, sink = false} =

      obox = DOM with div %
      name = gensym{}
      obox.id = name

      window.$currenti += 1
      window.$io.push with Outputter{obox}

      if display_in:
         @add_to_history{text}

      node1 = DOM with
         if display_in:
            then:
               div.[in] %
                  div.inbanner %
                  div.entry % @highlight{text}
            else:
               ""

      @target.appendChild{node1}
      @target.appendChild{obox}

      result = await @eval{text}

      node2 = f{result} where f{match} =
         when text.trim{} === "" ->
            ""
         #success{undefined?} ->
            ""
         #success{ENode? n} ->
            n
         #success{value} ->
            try:
               div.out %
                  div.outbanner %
                  div.result % .eg % repr{value}
            catch e:
               f{#failure{e}}
         #failure{error} ->
            console.error{error}
            div.err %
               div.errbanner %
               div.result % .eg % repr{error} !! e -> "Failed to print error."

      obox.appendChild with DOM{node2} with {
         async! wrapchange{f} =
            at_top = @box.scrollTop + jQuery{@box}.height{} == @box.scrollHeight
            f{}
            if at_top:
               ;; await wait{0}
               jQuery{@box}.scrollTop{@box.scrollHeight}
      }
      if sink:
         @sink{}

