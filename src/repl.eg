
require:
   codemirror as CodeMirror
   "codemirror/addon/runmode/runmode"
   "./earlmode"
   "./util" ->
      DOM, dom_node_clear, repr as _repr
      GenSym, wait
   jquery as jQuery

provide:
   Outputter, Repl, repr

globals:
   document, window, alert, setTimeout
   Element

let repr = _repr


gensym = GenSym{"io_"}



class Outputter:

   constructor{@elem} =
      pass

   log{*data} =
      @elem.appendChild with
         DOM with div %
            data each match x ->
               Element? or ENode? -> x
               else -> .eg % repr{x}
      undefined


class Repl:

   constructor{opts} =
      ;; Required fields
      {elements => {
          box => @box
          target => @target
          textarea => @textarea
          sink-anchor => @sink-anchor = @box
       }
       eval => @eval} = opts

      ;; Optional fields
      @inputline = opts.elements.inputline
      @keymap = opts.elements.keymap or {=}

      @keymap or= {=}
      @setup_cm{@textarea}
      @cursor = 0
      @history = {""}

   setup_cm{textarea} =

      @cm = CodeMirror.fromTextArea with
         textarea
         {
            indentUnit = 3
            viewportMargin = 1/0
            theme = .repl
            ;; lineNumbers = true
         }

      @cm.addKeyMap{km & @keymap} where km = {

         Enter{match cm} =
            do:
               e = cm.lineCount{} - 1
            when cm.getCursor{}.line < e ->
               CodeMirror.Pass
            else ->
               state = cm.getStateAfter{e}
               match:
                  when state.mode !== .code
                       \ or state.nest.length > 1
                       \ or R"lowprio|op"? state.previous
                       \ or [state.nest[0][2] > 0 and not R"^\s*$"? cm.getLine{e}] ->
                     CodeMirror.Pass
                  else ->
                     @submit{}

         "Shift-Enter" = "newlineAndIndent"

         "Ctrl-Enter"{cm} =
            @submit{}

         "Ctrl-Up"{cm} =
            if [@cursor > 0]:
               @cm.setValue with @history[-- @cursor]
               @cm.setCursor{@cm.lineCount{}, 0}
               @sink{}

         "Ctrl-Down"{cm} =
            if [@cursor < @history.length - 1]:
               @cm.setValue with @history[++ @cursor]
               @cm.setCursor{0, @cm.getLine{0}.length}
               @sink{}

         Up{match cm} =
            when @cursor > 0 and @cm.getCursor{}.line === 0 ->
               @cm.setValue with @history[-- @cursor]
               @cm.setCursor{@cm.lineCount{}, 0}
               @sink{}
            else ->
               CodeMirror.Pass

         Down{match cm} =
            when [@cursor < @history.length - 1 and
                  \ @cm.getCursor{}.line === [@cm.lineCount{} - 1]] ->
               @cm.setValue with @history[++ @cursor]
               @cm.setCursor{0, @cm.getLine{0}.length}
               @sink{}
            else ->
               CodeMirror.Pass

         Tab = "indentAuto"

         "Ctrl-L"{_} =
            jQuery{@target}.empty{}

         "Ctrl-A" = "goLineStart"
         "Ctrl-E" = "goLineEnd"
         "Ctrl-K" = "killLine"
      }

      @cm.setOption{"mode", "earl-grey"}
      @cm.setSize{.auto, .auto}

   sink{} =
      setTimeout{f, 0} where f{} =
         jQuery{@sink-anchor}.scrollTop{@sink-anchor.scrollHeight}

   add_to_history{text} =
      hl = @history.length
      if [text !== "" and not [hl > 1 and @history[hl - 2] == text]]:
         ;; Only add to history if the command was nonempty
         ;; and we're not repeating the same command
         @history[hl - 1] = text
         @history.push{""}
      @cursor = @history.length - 1

   async submit{} =
      text = @cm.getValue{}
      if @inputline:
         jQuery{@inputline}.hide{}
      var done = false
      try:
         await any {
            f{} where async f{} =
               res = await @process_all{text, true, true}
               done = true
               res
            wait{10000}
         }
         ;; await @process_all{text, true, true}
      catch e:
         done = true
         console.log with e.stack
      if not done:
         window.$io[window.$currenti].log with 
            "Request is taking too much time... executing in the background..."
      if @inputline:
         jQuery{@inputline}.show{}
      @cm.setValue{""}
      @cm.focus{}

   highlight{text, inline = false} =
      hl = {}
      CodeMirror.runMode{text or " ", "earl-grey"} with {text, style} ->
         hl.push with
            if style:
               then: span[^[".cm-" + style]] % text
               else: span % text
      if inline:
         span".cm-s-repl" %
            hl
      else:
         div".cm-s-repl" %
            hl

   async process_all{text, display_in = true, sink = false} =
      text.split{"\n===\n"} each part ->
         await @process{part, display_in, sink}

   async process{text, display_in = true, sink = false} =

      ;; Show the input
      if display_in:
         @add_to_history{text}
         @target.appendChild with DOM with
            div.[in] %
               div.inbanner %
               div.entry % @highlight{text}
         if sink:
            @sink{}

      ;; Set up the output box
      obox = DOM with
         div % id = gensym{}
      window.$currenti += 1
      window.$io.push with Outputter{obox}
      @target.appendChild{obox}

      ;; Compute the result
      result = await @eval{text}

      ;; Display the result
      obox.appendChild with DOM{node, opts} where

         node = f{result} where f{match} =
            when text.trim{} === "" ->
               ""
            #success{undefined?} ->
               ""
            #success{ENode? n} ->
               n
            #success{value} ->
               try:
                  div.out %
                     div.outbanner %
                     div.result % .eg % repr{value}
               catch e:
                  f{#failure{e}}
            #failure{error} ->
               console.error{error}
               div.err %
                  div.errbanner %
                  div.result % .eg % repr{error} !! e -> "Failed to print error."

         opts = {
            async wrapchange{f} =
               at_top = @box.scrollTop + jQuery{@box}.height{} == @box.scrollHeight
               f{}
               if at_top:
                  jQuery{@box}.scrollTop{@box.scrollHeight}
         }

      ;; Optionally pull the focus to the bottom where the result is
      if sink:
         @sink{}

