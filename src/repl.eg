
require:
   "./kb" as kb
   "earl-grey/earl-grey" as eg
   "earl-grey/util" ->
      GenSym
   "earl-grey/location" ->
      Location, highlight_locations
      format_error
   "earl-grey/lex" ->
      tokenize
   "earl-grey/parse" ->
      parse
   quaint
   codemirror as CodeMirror
   "codemirror/addon/runmode/runmode"
   "./earlmode"
   "./javascript"

provide:
   Repl, kb.Interactor as Interactor
   parse, tokenize, eg.Source as Source
   make_cards
   setup

globals:
   document, window, alert, jQuery, setTimeout
   ;; CodeMirror

gensym = GenSym{"io_"}


;; macro [%]{context, scope, {=> env}, #data{descr, contents}}:

;;    tag = .div
;;    cls = {}
;;    id = null
;;    kv = '{=}

;;    parse{match whole} =
;;       #void{} -> null
;;       #symbol{s} ->
;;          tag = s
;;       #value{x} ->
;;          cls.push with x
;;       '[. ^[#symbol{x} or #value{x}]] ->
;;          cls.push with x
;;       '[# ^[#symbol{x} or #value{x}]] ->
;;          id = #value{x}
;;       '[^_ = ^_] ->
;;          kv.push with whole
;;       #send{expr, rest} ->
;;          parse{expr}, parse{rest}
;;       #multi{*args} or #data{*args} ->
;;          args each arg -> parse{arg}

;;    parse{descr}

;;    if id:
;;       kv.push with '["id" = ^id]
;;    if cls.length:
;;       kv.push with '["className" = ^=cls.join{" "}]

;;    contents ?=
;;       #void{} -> #array{}
;;       #multi{*args} ->
;;          xs = {}
;;          args each
;;             pair and '[^k = ^v] ->
;;                kv.push with pair
;;             splice and '[** ^_] ->
;;                kv.push with splice
;;             other ->
;;                xs.push with other
;;          #array{*xs}
;;       pair and '[^k = ^v] ->
;;          kv.push with pair
;;          #array{}
;;       x -> x

;;    '[^env.convert{'create_node}]{^=tag, ^kv, ^contents}


create_node{tag, kv, contents} =
   node = document.createElement{tag}
   items{kv} each {k, v} ->
      node[k] = v
   [Array! contents] each
      String? s ->
         node.appendChild{document.createTextNode{s}}
      other ->
         node.appendChild{other}
   node


make_dom{match, default_tag = "div"} =

   String? s ->
      document.createTextNode{s}

   Array? args ->
      node = document.createElement{"span"}
      args each arg ->
         node.appendChild{make_dom{arg, default_tag}}
      node

   Node? {=> tags, => props, => children} ->
      var tag = default_tag
      classes = {}
      tags each
         R"^\\.(.*)"! {_, name} ->
            classes.push{name}
         other ->
            tag = other

      node = document.createElement{tag}
      if classes.length:
         node.className = classes.join{" "}
      items{props} each {k, v} ->
         node[k] = v

      match tag:
         .raw ->
            children each
               String? s ->
                  node.innerHTML = s
         other ->
            children each c ->
               node.appendChild{make_dom{c, default_tag}}

      node

   ;; Node? {=> classes, => children} ->
   ;;    var tag = default_tag
   ;;    _classes = {}
   ;;    var id = null
   ;;    kv = {}
   ;;    sub = {}
   ;;    classes each
   ;;       #assoc{k, v} ->
   ;;          kv.push with {k, v}
   ;;       #assoc{k} ->
   ;;          kv.push with {k, undefined}
   ;;       R'[start, "+", {*any}]! {_, m} ->
   ;;          tag = m
   ;;       R'[start, "#", {*any}]! {_, m} ->
   ;;          id = m
   ;;       String? s ->
   ;;          _classes.push with s

   ;;    node = document.createElement{tag}
   ;;    if id:
   ;;       node.id = id
   ;;    if _classes.length:
   ;;       node.className = _classes.join{" "}
   ;;    kv each {k, v} ->
   ;;       node[k] = v

   ;;    match tag:
   ;;       .raw ->
   ;;          children each
   ;;             String? s ->
   ;;                node.innerHTML = s
   ;;       other ->
   ;;          children each c ->
   ;;             node.appendChild{make_dom{c, default_tag}}

   ;;    node

   other ->
      make_dom{String! other}

mktable{x, recur = repr} =
   its = match x:
      Array? -> x
      other -> items{x}
   if its.length:
      then:
         table.object %
            its each {k, v} ->
               tr %
                  th % recur{k, repr}
                  td % recur{v, repr}
      else:
         .object.empty %

repr{match x, Function? recur = repr} =
   === true -> .special.true % "true"
   === false -> .special.false % "false"
   null? -> .special.nil % "null"
   undefined? -> .special.nil % "undefined"
   Number? -> .num % String{x}
   "" -> .str.empty %
   String? -> .str % x
   Array? {} -> .sequence.empty %
   Array? entries ->
      .sequence % [entries each x -> recur{x, repr}]
   Node? n ->
      n
   when x["::repr"] ->
      x["::repr"]{recur}
   when Object.getPrototypeOf{x} === Object.prototype ->
      mktable{x}
   when x.constructor and x.constructor["::egclass"] ->
      .instance %
         .classname % x.constructor["::name"]
         mktable{x}
   when x["::egclass"] ->
      .class %
         .classname % "Class " + x["::name"]
         mktable{x.prototype}
   Function? f ->
      .function % if{f.name, f.name, "<anonymous>"}
   other ->
      .unknown % other.toString{}


goto_end{elem} =
   let range = document.createRange{}
   range.selectNodeContents{elem}
   range.collapse{false}
   selection = window.getSelection{}
   selection.removeAllRanges{}
   selection.addRange{range}

insert_before_caret{text} =
   node = match text:
      String? -> document.createTextNode{text}
      other -> other
   sel = window.getSelection{}
   if sel.rangeCount:
      var range = sel.getRangeAt{0}
      using range:
         @collapse{false}
         @insertNode{node}
      range = range.cloneRange{}
      using range:
         @selectNodeContents{node}
         @collapse{false}
      sel.removeAllRanges{}
      sel.addRange{range}


Error.prototype["::repr"] = {} ->
   format_error{this}


class Repl:

   constructor{@box, @target, @inputbox, @textarea, @evaluator} =

      @url = "<repl>"
      @gen = eg.Generator{true}

      ;; @input = input
      @multiline = false

      @setup_cm{@textarea}

      ;; @interactor = kb.Interactor{{=}}
      @set_multiline{false}
      ;; @interactor.install{@input}

      @cursor = 0
      @history = {""}


   setup_cm{textarea} =

      @cm = CodeMirror.fromTextArea with
         textarea
         {
            indentUnit = 3
            viewportMargin = 1/0
            ;; lineNumbers = true
         }

      @cm.addKeyMap{{...}} with

         Enter{match cm} =
            when @multiline ->
               CodeMirror.Pass
            else ->
               e = cm.lineCount{} - 1
               state = cm.getStateAfter{e}
               match:
                  when state.nest.length > 1
                       \ or R"lowprio|op"? state.previous
                       \ or [state.nest[0][1] > 0 and not R"^\\s*$"? cm.getLine{e}] ->
                     CodeMirror.Pass
                  else ->
                     @submit{}

               ;; {=> line, => ch} = cm.getCursor{}
               ;; re = R"(=|->|%|:|with|where|each)$"
               ;; match line:
               ;;    do: txt = cm.getLine{0}
               ;;    0 when ch == txt.length and re? txt ->
               ;;       @set_multiline{true}
               ;;       CodeMirror.Pass
               ;;    else ->
               ;;       @submit{}

         "Shift-Enter"{cm} =
            @submit{}

         Up{match cm} =
            when @cursor > 0 and @cm.getCursor{}.line === 0 ->
               @cm.setValue with @history[-- @cursor]
               @cm.setCursor{@cm.lineCount{}, 0}
               @set_multiline{@cm.lineCount{} > 1}
               @sink{}
            else ->
               CodeMirror.Pass

         Down{match cm} =
            when [@cursor < @history.length - 1 and
                  \ @cm.getCursor{}.line === [@cm.lineCount{} - 1]] ->
               @cm.setValue with @history[++ @cursor]
               @cm.setCursor{0, @cm.getLine{0}.length}
               @set_multiline{@cm.lineCount{} > 1}
               @sink{}
            else ->
               CodeMirror.Pass

         Tab = "indentAuto"

         "Ctrl-M"{_} =
            @set_multiline{not @multiline}

         "Ctrl-L"{_} =
            jQuery{@target}.empty{}

         "Ctrl-A" = "goLineStart"
         "Ctrl-E" = "goLineEnd"
         "Ctrl-K" = "killLine"

      @cm.setOption{"mode", "earl-grey"}
      ;; @cm.setOption{"mode", "javascript"}
      @cm.setSize{.auto, .auto}

   sink{} =
      setTimeout{..., 0} with {} ->
         jQuery{@box}.scrollTop{@box.scrollHeight}

   add_to_history{text} =
      hl = @history.length
      if [text !== "" and not [hl > 1 and @history[hl - 2] == text]]:
         ;; Only add to history if the command was nonempty
         ;; and we're not repeating the same command
         @history[hl - 1] = text
         @history.push{""}
      @cursor = @history.length - 1

   ;; submit{} =
   ;;    @set_multiline{false}
   ;;    text = @input.textContent
   ;;    @process{text}
   ;;    @input.innerHTML = ""
   ;;    @sink{}

   submit{} =
      @set_multiline{false}
      text = @cm.getValue{}
      @process{text}
      @cm.setValue{""}
      @sink{}

   set_multiline{match @multiline} =
      true? ->
         jQuery{@inputbox}.addClass{.multiline}
      false? ->
         jQuery{@inputbox}.removeClass{.multiline}

   ;; begin_multiline{} =
   ;;    @set_multiline{true}
   ;;    ;; @input.innerHTML = @input.innerHTML + "\n   "
   ;;    goto_end{@input}
   ;;    insert_before_caret{"\n   "}
   ;;    @sink{}

   ;; set_multiline{x} = match x:
   ;;    do:
   ;;       @multiline = x
   ;;       previous{} =
   ;;          if [@cursor > 0]:
   ;;             @input.textContent = @history[-- @cursor]
   ;;             goto_end{@input}
   ;;             @sink{}
   ;;       next{} =
   ;;          if [@cursor < @history.length - 1]:
   ;;             @input.textContent = @history[++ @cursor]
   ;;             goto_end{@input}
   ;;             @sink{}
   ;;       common = {
   ;;          "C-l"{} =
   ;;             jQuery{@target}.empty{}
   ;;          "S-Enter"{} =
   ;;             @submit{}
   ;;       }

   ;;    === false ->
   ;;       jQuery{@input}.removeClass{.multiline}
   ;;       @interactor.set_bindings with common & {
   ;;          "C-m"{} =
   ;;             @set_multiline{true}
   ;;             .break
   ;;          "C-Enter"{} =
   ;;             @begin_multiline{}
   ;;             .break
   ;;          Enter{} =
   ;;             match @input.textContent:
   ;;                R"(=|->|%|:|with|where|each)$"? ->
   ;;                   @begin_multiline{}
   ;;                other ->
   ;;                   @submit{}
   ;;          Up = previous
   ;;          Down = next
   ;;       }

   ;;    === true ->
   ;;       jQuery{@input}.addClass{.multiline}
   ;;       @interactor.set_bindings with common & {
   ;;          "C-m"{} =
   ;;             @set_multiline{false}
   ;;             .break
   ;;          "C-Enter"{} =
   ;;             @submit{}
   ;;          Enter{} =
   ;;             insert_before_caret{"\n"}
   ;;             @sink{}
   ;;          Tab{} =
   ;;             insert_before_caret{"   "}
   ;;       }

   generate{text} =
      @gen.generate{eg.Source{text, @url}}

   eval{text} =
      [gen{} !! e -> handle{e}] where
         gen{} =
            g = @generate{text}
            #success{@evaluator{g}}
         handle{e} =
            #failure{e}

   process{text, display_in = true} =
      @add_to_history{text}
      real_text = text ;; "\n" + text + "\n"
      node = make_dom with
         .io %
            if display_in:
               then:
                  hl = {}
                  CodeMirror.runMode{text or " ", "earl-grey"} with {text, style} ->
                     hl.push with
                        if style:
                           then: span ^[".cm-" + style] % text
                           else: span % text
                  .[in] %
                     .inbanner %
                     .entry %
                        ".cm-s-default" %
                           hl
               else:
                  ""
            match @eval{real_text}:
               when text.trim{} === "" ->
                  ""
               #success{undefined?} ->
                  ""
               #success{Node? n} ->
                  .display %
                     n
                     ;; .displaybanner %
                     ;; .result % n
               #success{value} ->
                  .out %
                     .outbanner %
                     .result % .eg % repr{value}
               #failure{error} ->
                  .err %
                     .errbanner %
                     .result % .eg % repr{error}

      name = gensym{}
      node.id = name

      @target.appendChild{node}

      collapse{e} =
         e.stopPropagation{}
         at_top = @box.scrollTop + jQuery{@box}.height{} == @box.scrollHeight
         jQuery{this}.toggleClass{"collapsed"}
         if at_top:
            jQuery{@box}.scrollTop{@box.scrollHeight}

      on{sel} =
         jQuery{"#" + name + " " + sel}

      on{".sequence"}.addClass{"complex"}
      on{".object"}.addClass{"complex"}
      
      on{".complex"}.click{collapse}
      on{".complex .complex .complex"}.addClass{.collapsed}

      on{".error_args.syntax"}.addClass{.collapsed}.click{collapse}
      on{".traceback"}.addClass{.collapsed}.click{collapse}


macro static_read{*, #value{filename}}:
   require: fs
   globals: __dirname
   f = __dirname + "/" + filename
   contents = fs.readFileSync{f, .utf8}
   #value{contents}


make_cards{repl} =

   mktable2{x, recur = repr} =
      its = match x:
         Array? -> x
         other -> items{x}
      table %
         its each {k, v} ->
            tr %
               th % recur{k, repr}
               td % recur{v, repr}

   clickable{code, text = null} =
      click{e} =
         e.preventDefault{}
         repl.process{code}
         repl.sink{}
         ;; jQuery{repl.input}.focus{}
         repl.cm.focus{}
      cls = match code:
         R"^help"? -> ".help"
         else -> ".clickable"
      ^cls %
         onclick = click
         text or code

   clickable_row{*items} =
      span %
         items each
            first item ->
               clickable{item}
            item ->
               span % [span.separator % "", clickable{item}]

   getcode{node} =
      code = shed{node}.location.text{}
      lines = code.split{"\n"}
      while [R"^ *$"? lines[0]]:
         lines.shift{}
      while [R"^ *$"? lines[lines.length - 1]]:
         lines.pop{}
      R"( *)(.*)"! {_, indent, line0} = lines[0]
      nindent = indent.length
      xs.join{"\n"} where
         xs = {line0} ++
            lines.slice{1} each line ->
               line.slice{nindent}

   shed{node} =
      chain node:
         quaint.shed{@}
         ;; quaint.shed_indent{@}

   dispatch = quaint.dispatch.clone{}
   components = {...} with

      "maybe label / code"{engine, node, {label => match, => code}} =
         #text{""} ->
            match quaint.collapse{"/", code}:
               {x} -> clickable{getcode{x}}
               {*xs} -> clickable_row{*xs2} where
                  xs2 = xs each x -> getcode{x}
         label ->
            clickable with
               getcode{code}
               shed{label}.location.text{}

      "topic --> contents"{engine, node, {=> topic, => contents}} =
         cards[topic.location.text{}] =
            .card % engine.run{contents}

      "topic --> desc --> contents"{engine, node, {=> topic, => desc, => contents}} =
         cards[topic.location.text{}] =
            [.card % engine.run{contents}] &:
               {description = engine.run{desc}}

   items{components} each {spec, fn} ->
      dispatch.register with quaint.Spec{spec, fn}

   var cards = {=}

   files = {
      static_read "tutorial.q"
      static_read "basic.q"
      static_read "cards.q"
      static_read "examples.q"
   }

   Q = quaint.Engine{dispatch}

   files each file ->
      Q.run{file}

   tutorial = {}
   var i = 0
   while cards["tut" + String{i}]:
      tutorial.push with
         cards["tut" + String{i}]
      i += 1

   tutorial.description = "Earl Grey tutorial"
   cards.tutorial = tutorial

   cards.topics = .card %
      h3 % "Help topics"
      mktable2{{...}} with
         {clickable{"help topics"}, "List all help topics"}
         {clickable{"help variables"}, "Declaring and setting variables"}
         {clickable{"help blocks"}, "Blocks and indent rules"}
   cards.topics.description = "Help starting point"

   cards.index = .card %
      h3 % "Index"
      mktable2 with
         items{cards}.sort{} each
            {k, v} when not R"^tut[0-9]+"? k ->
               {clickable{"help " + k, k}, v.description}

   cards



setup{} =

   repl = Repl with
      document.getElementById{"box"}
      document.getElementById{"interactive"}
      document.getElementById{"inputbox"}
      document.getElementById{"code"}
      eval

   window._cards = make_cards{repl}

   repl.eval with "

      globals:
         _cards, alert, document
         window, _current, _next, _help

      var _current = 0

      _next{} =
         _current += 1
         _cards.tutorial[_current]

      _help{match} =
         \"\" -> _cards.topics
         topic -> _cards[topic] or [\"Invalid help topic: \\\"\" + topic + \"\\\"\"]

      macro next{_, _, form, _}:
         '[^form.env.mark{'_next}]{}

      macro help{_, _, form, match}:
         do: h = form.env.mark{'_help}
         #symbol{topic} or #value{topic} ->
            '[^h]{^=topic}
         #void{} -> '[^h]{}
   "

   repl.process{"_cards.tutorial[0]", false}
   ;; jQuery{"#input"}.focus{}
   repl.cm.focus{}

   repl



