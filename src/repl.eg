
require:
   "./kb" as kb
   "earl-grey/earl-grey" as eg
   "earl-grey/util" ->
      GenSym
   "earl-grey/location" ->
      Location, highlight_locations
      format_error
   "earl-grey/lex" ->
      tokenize
   "earl-grey/parse" ->
      parse
   quaint
   codemirror as CodeMirror
   "codemirror/addon/runmode/runmode"
   "./earlmode"
   "./javascript"

provide:
   Repl, kb.Interactor as Interactor
   parse, tokenize, eg.Source as Source
   make_cards
   setup

globals:
   document, window, alert, jQuery, setTimeout
   ;; CodeMirror

gensym = GenSym{"io_"}


create_node{tag, kv, contents} =
   node = document.createElement{tag}
   items{kv} each {k, v} ->
      node[k] = v
   [Array! contents] each
      String? s ->
         node.appendChild{document.createTextNode{s}}
      other ->
         node.appendChild{other}
   node


make_dom{match, default_tag = "div"} =

   String? s ->
      document.createTextNode{s}

   Array? args ->
      node = document.createElement{"span"}
      args each arg ->
         node.appendChild{make_dom{arg, default_tag}}
      node

   Node? {=> tags, => props, => children} ->
      var tag = default_tag
      classes = {}
      tags each
         R"^\\.(.*)"! {_, name} ->
            classes.push{name}
         other ->
            tag = other

      node = document.createElement{tag}
      if classes.length:
         node.className = classes.join{" "}
      items{props} each {k, v} ->
         node[k] = v

      match tag:
         .raw ->
            children each
               String? s ->
                  node.innerHTML = s
         other ->
            children each c ->
               node.appendChild{make_dom{c, default_tag}}

      node

   other ->
      make_dom{String! other}

mktable{x, recur = repr} =
   its = match x:
      Array? -> x
      other -> items{x}
   if its.length:
      then:
         table.object %
            its each {k, v} ->
               tr %
                  th % recur{k, repr}
                  td % recur{v, repr}
      else:
         .object.empty %

repr{match x, Function? recur = repr} =
   === true -> .special.true % "true"
   === false -> .special.false % "false"
   null? -> .special.nil % "null"
   undefined? -> .special.nil % "undefined"
   Number? -> .num % String{x}
   "" -> .str.empty %
   String? -> .str % x
   Array? {} -> .sequence.empty %
   Array? entries ->
      .sequence % [entries each x -> recur{x, repr}]
   Node? n ->
      n
   when x["::repr"] ->
      x["::repr"]{recur}
   when Object.getPrototypeOf{x} === Object.prototype ->
      mktable{x}
   when x.constructor and x.constructor["::egclass"] ->
      .instance %
         .classname % x.constructor["::name"]
         mktable{x}
   when x["::egclass"] ->
      .class %
         .classname % "Class " + x["::name"]
         mktable{x.prototype}
   Function? f ->
      .function % if{f.name, f.name, "<anonymous>"}
   other ->
      .unknown % other.toString{}


goto_end{elem} =
   let range = document.createRange{}
   range.selectNodeContents{elem}
   range.collapse{false}
   selection = window.getSelection{}
   selection.removeAllRanges{}
   selection.addRange{range}

insert_before_caret{text} =
   node = match text:
      String? -> document.createTextNode{text}
      other -> other
   sel = window.getSelection{}
   if sel.rangeCount:
      var range = sel.getRangeAt{0}
      using range:
         @collapse{false}
         @insertNode{node}
      range = range.cloneRange{}
      using range:
         @selectNodeContents{node}
         @collapse{false}
      sel.removeAllRanges{}
      sel.addRange{range}


Error.prototype["::repr"] = {} ->
   format_error{this}

dom_node_clear{x} =
   while x.children.length > 0:
      x.removeChild{x.children[0]}


class Repl:


   constructor{@box, @target, @inputbox, @textarea, @evaluator, @target2} =
      @url = "<repl>"
      @gen = eg.Generator{true}
      @setup_cm{@textarea}
      @cursor = 0
      @history = {""}
      @tabs = {}

   make_history_label{tab, pos, label, cls} =
      ^["." + cls] %
         label
         onclick{e} =
            @focus_page{tab, pos}

   gettab{match tab} =
      do:
         create{} =
            pages = {}
            box = make_dom with
               div.tab %
                  div.tab_header %
                     div.breadcrumbs %
                     div.close_tab %
                        onclick{e} =
                           @tabs[tab] = null
                           dom_node_clear with
                              @target2.children[tab]
                  div % [div %]
            data = {pages, box.children[0].children[0], box.children[1], -1}
            {box, data}

      when @tabs[tab] ->
         @tabs[tab]

      when @tabs[tab] === null ->
         {box, data} = create{}
         @tabs[tab] = data
         @target2.replaceChild with
            box
            @target2.children[tab]
         data

      when tab == @tabs.length ->
         {box, data} = create{}
         @tabs.push with data
         @target2.appendChild with box
         data

      else ->
         throw E.repl.no_such_tab{tab}

   insert_page{tab, var pos, label, page} =
      {pages, ltarget, ptarget, current} = @gettab{tab}
      if pos == -1:
         pos = current + 1 ;;pages.length
      pages.splice{pos}
      pages.push with {label, page}
      @focus_page{tab, pos}

   focus_page{tab, pos} =
      {pages, ltarget, ptarget, _} = @tabs[tab]
      @tabs[tab][3] = pos
      mkh{pos, label, cls} = @make_history_label{tab, pos, label, cls}
      dom_node_clear{ltarget}
      enumerate{pages} each {i, {name, page}} ->
         ltarget.appendChild with make_dom with
            match i:
               < pos  -> mkh{i, name, .previous_page}
               == pos -> mkh{i, name, .current_page}
               > pos  -> mkh{i, name, .next_page}
         if i < pages.length - 1:
            ltarget.appendChild with make_dom with span.history_separator %
      {_, page} = pages[pos]
      ptarget.replaceChild{..., ptarget.children[0]} with make_dom with page


   setup_cm{textarea} =

      @cm = CodeMirror.fromTextArea with
         textarea
         {
            indentUnit = 3
            viewportMargin = 1/0
            theme = .repl
            ;; lineNumbers = true
         }

      @cm.addKeyMap{{...}} with

         Enter{match cm} =
            do:
               e = cm.lineCount{} - 1
            when cm.getCursor{}.line < e ->
               CodeMirror.Pass
            else ->
               state = cm.getStateAfter{e}
               match:
                  when state.mode !== .code
                       \ or state.nest.length > 1
                       \ or R"lowprio|op"? state.previous
                       \ or [state.nest[0][1] > 0 and not R"^\\s*$"? cm.getLine{e}] ->
                     CodeMirror.Pass
                  else ->
                     @submit{}

         "Ctrl-Enter" = "newlineAndIndent"

         "Shift-Enter"{cm} =
            @submit{}

         "Ctrl-Up"{cm} =
            if [@cursor > 0]:
               @cm.setValue with @history[-- @cursor]
               @cm.setCursor{@cm.lineCount{}, 0}
               @sink{}

         "Ctrl-Down"{cm} =
            if [@cursor < @history.length - 1]:
               @cm.setValue with @history[++ @cursor]
               @cm.setCursor{0, @cm.getLine{0}.length}
               @sink{}

         Up{match cm} =
            when @cursor > 0 and @cm.getCursor{}.line === 0 ->
               @cm.setValue with @history[-- @cursor]
               @cm.setCursor{@cm.lineCount{}, 0}
               @sink{}
            else ->
               CodeMirror.Pass

         Down{match cm} =
            when [@cursor < @history.length - 1 and
                  \ @cm.getCursor{}.line === [@cm.lineCount{} - 1]] ->
               @cm.setValue with @history[++ @cursor]
               @cm.setCursor{0, @cm.getLine{0}.length}
               @sink{}
            else ->
               CodeMirror.Pass

         Tab = "indentAuto"

         "Ctrl-L"{_} =
            jQuery{@target}.empty{}

         "Ctrl-A" = "goLineStart"
         "Ctrl-E" = "goLineEnd"
         "Ctrl-K" = "killLine"

      @cm.setOption{"mode", "earl-grey"}
      ;; @cm.setOption{"mode", "javascript"}
      @cm.setSize{.auto, .auto}

   sink{} =
      setTimeout{..., 0} with {} ->
         jQuery{@box}.scrollTop{@box.scrollHeight}

   sink2{} =
      setTimeout{..., 0} with {} ->
         match.indexable @target2.childNodes:
            {*, ch} ->
               jQuery{@target2}.scrollTop{@target2.scrollHeight - jQuery{ch}.height{}}
            else ->
               pass

   add_to_history{text} =
      hl = @history.length
      if [text !== "" and not [hl > 1 and @history[hl - 2] == text]]:
         ;; Only add to history if the command was nonempty
         ;; and we're not repeating the same command
         @history[hl - 1] = text
         @history.push{""}
      @cursor = @history.length - 1

   submit{} =
      text = @cm.getValue{}
      @cm.setValue{""}
      @process{text, true, true}

   generate{text} =
      @gen.generate{eg.Source{text, @url}}

   eval{text} =
      [gen{} !! e -> handle{e}] where
         gen{} =
            g = @generate{text}
            #success{@evaluator{g}}
         handle{e} =
            #failure{e}

   highlight{text} =
      hl = {}
      CodeMirror.runMode{text or " ", "earl-grey"} with {text, style} ->
         hl.push with
            if style:
               then: span ^[".cm-" + style] % text
               else: span % text
      ".cm-s-repl" %
         hl

   process{text, display_in = true, var sink = false} =
      @add_to_history{text}
      real_text = text ;; "\n" + text + "\n"
      var target = 1
      sink and= 1
      node1 = make_dom with
         if display_in:
            then:
               .[in] %
                  .inbanner %
                  .entry % @highlight{text}
            else:
               ""
      node2 =
         match @eval{real_text}:
            when text.trim{} === "" ->
               ""
            #success{undefined?} ->
               ""
            #success{Node? n} ->
               if [.card %]? n:
                  target = 2
                  sink and= 2
               n
               ;; .displaybanner %
               ;; .result % n
            #success{value} ->
               .out %
                  .outbanner %
                  .result % .eg % repr{value}
            #failure{error} ->
               .err %
                  .errbanner %
                  .result % .eg % repr{error}

      name = gensym{}
      ;; node2.props.id = name

      @target.appendChild{node1}

      match target:
         1 -> @target.appendChild{make_dom with node2}
         2 -> @insert_page{0, -1, node2.title or "untitled", node2}

      ;; target.appendChild{node2}

      match sink:
         1 -> @sink{}
         ;; 2 -> @sink2{}
         else -> pass

      collapse{e} =
         e.stopPropagation{}
         at_top = @box.scrollTop + jQuery{@box}.height{} == @box.scrollHeight
         jQuery{this}.toggleClass{"collapsed"}
         if at_top:
            jQuery{@box}.scrollTop{@box.scrollHeight}

      on{sel} =
         jQuery{"#" + name + " " + sel}

      on{".sequence"}.addClass{"complex"}
      on{".object"}.addClass{"complex"}
      
      on{".complex"}.click{collapse}
      on{".complex .complex .complex"}.addClass{.collapsed}

      on{".error_args.syntax"}.addClass{.collapsed}.click{collapse}
      on{".traceback"}.addClass{.collapsed}.click{collapse}



macro acquire_cards{*, #data{*filenames}}:

   globals: __dirname

   dirname = __dirname
   require: [fs, quaint]

   results = #data{}
   dispatch = quaint.dispatch.clone{}
   components = {...} with

      "topic --> contents"{engine, node, {=> topic, => contents}} =
         results.push with #data with
            #value{topic.location.text{}}
            #value{""}
            #value{contents.location.text{}}

      "topic --> desc --> contents"{engine, node, {=> topic, => desc, => contents}} =
         results.push with #data with
            #value{topic.location.text{}}
            #value{desc.location.text{}}
            #value{contents.location.text{}}

   items{components} each {spec, fn} ->
      dispatch.register with quaint.Spec{spec, fn}

   Q = quaint.Engine{dispatch}

   filenames each #value{filename} ->
      f = dirname + "/" + filename
      contents = fs.readFileSync{f, .utf8}
      Q.run{contents}

   ;; quaint mucks this up for some reason
   set __dirname = dirname

   results

__cards =
   raw = acquire_cards with
      "basic.q"
      "cards.q"
      "examples.q"
      "advanced.q"
   rval = object with raw each {topic, description, text} ->
      {topic, {description, text}}

display_card{repl, tab, code} =
   pass






macro static_read{*, #value{filename}}:
   require: fs
   globals: __dirname
   f = __dirname + "/" + filename
   contents = fs.readFileSync{f, .utf8}
   #value{contents}


make_cards{repl} =

   mktable2{x, recur = repr} =
      its = match x:
         Array? -> x
         other -> items{x}
      table %
         its each {k, v} ->
            tr %
               th % recur{k, repr}
               td % recur{v, repr}

   clickable{code, text = null} =
      click{e} =
         e.preventDefault{}
         repl.process{code, true, true}
         ;; repl.sink{}
         ;; jQuery{repl.input}.focus{}
         repl.cm.focus{}
      cls = match code:
         R"^help"? -> ".help"
         else -> ".clickable"
      ^cls %
         onclick = click
         text or repl.highlight{code}

   clickable_row{items} =
      span %
         items each
            first item ->
               clickable{*item}
            item ->
               span % [span.separator % "", clickable{*item}]

   getcode{node} =
      code = shed{node}.location.text{}
      lines = code.split{"\n"}
      while [R"^ *$"? lines[0]]:
         lines.shift{}
      while [R"^ *$"? lines[lines.length - 1]]:
         lines.pop{}
      R"( *)(.*)"! {_, indent, line0} = lines[0]
      nindent = indent.length
      xs.join{"\n"} where
         xs = {line0} ++
            lines.slice{1} each line ->
               line.slice{nindent}

   shed{node} =
      chain node:
         quaint.shed{@}
         ;; quaint.shed_indent{@}

   dispatch = quaint.dispatch.clone{}
   components = {...} with

      "maybe label / code"{engine, node, {label => match, => code}} =
         #text{""} ->
            match quaint.collapse{"/", code}:
               {x} -> clickable{getcode{x}}
               {*xs} -> clickable_row{xs2} where
                  xs2 = xs each x -> {z, null} where z = getcode{x}
         label ->
            clickable with
               getcode{code}
               shed{label}.location.text{}

      "maybe label /? topic"{engine, node, {label => match, => topic}} =
         do:
            helpify{x} =
               "help \"" + x + "\""
         #text{""} ->
            match quaint.collapse{"/", topic}:
               {x} -> clickable{helpify{code}, code} where code = getcode{x}
               {*xs} -> clickable_row{xs2} where
                  xs2 = xs each x ->
                     {helpify{code}, code} where code = getcode{x}
         label ->
            clickable with
               helpify{getcode{topic}}
               shed{label}.location.text{}

      "topic --> contents"{engine, node, {=> topic, => contents}} =
         cards[topic.location.text{}] =
            .card % engine.run{contents}

      "topic --> desc --> contents"{engine, node, {=> topic, => desc, => contents}} =
         topic_text = topic.location.text{}
         cards[topic_text] =
            [.card % engine.run{contents}] &:
               {description = engine.run{desc}
                title = topic_text}

   items{components} each {spec, fn} ->
      dispatch.register with quaint.Spec{spec, fn}

   var cards = {=}

   files = {
      ;; static_read "tutorial.q"
      static_read "basic.q"
      static_read "cards.q"
      static_read "examples.q"
      static_read "advanced.q"
   }

   Q = quaint.Engine{dispatch}

   files each file ->
      Q.run{file}

   tutorial = {}
   var i = 0
   while cards["tut" + String{i}]:
      tutorial.push with
         cards["tut" + String{i}]
      i += 1

   tutorial.description = "Earl Grey tutorial"
   cards.tutorial = tutorial

   cards.index = .card % .blocks %
      h3 % "Index"
      mktable2 with
         items{cards}.sort{} each
            {k, v} when not R"^tut[0-9]+"? k ->
               {clickable{"help \"" + k + "\"", k}, v.description}
   cards.index.description = "Help index"
   cards.index.title = "index"

   {cards, Q}



setup{} =

   repl = Repl with
      document.getElementById{"box"}
      document.getElementById{"interactive"}
      document.getElementById{"inputbox"}
      document.getElementById{"code"}
      eval
      document.getElementById{"help"}

   {window._cards, engine} = make_cards{repl}
   ;; {window._cards, engine} = {{=}, null}
   window.quaint = quaint & {engine = engine}

   repl.eval with "

      globals:
         _cards, alert, document
         window, _current, _next, _help
         quaint, repl

      var _current = -1

      _next{} =
         _current = [_current + 1] mod _cards.tutorial.length
         _cards.tutorial[_current] or \"There is no tutorial yet.\"

      _help{match} =
         \"\" -> _cards.topics
         topic -> _cards[topic] or [\"Invalid help topic: \\\"\" + topic + \"\\\"\"]

      macro next{_, _, form, _}:
         '[^form.env.mark{'_next}]{}

      macro help{_, _, form, match}:
         do: h = form.env.mark{'_help}
         #symbol{topic} or #value{topic} ->
            '[^h]{^=topic}
         #void{} -> '[^h]{\"\"}

      macro Q{_, _, _, arg}:
         '[.card % quaint.engine.run{^arg}]
   "

   repl.process{"help main", false}
   ;; jQuery{"#input"}.focus{}
   repl.cm.focus{}

   repl



