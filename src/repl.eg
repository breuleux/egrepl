
require:
   "./kb" as kb
   "../lib/earl-grey" as eg
   "../lib/util" ->
      GenSym
   "../lib/location" ->
      Location, highlight_locations
      format_error
   "../lib/lex" ->
      tokenize
   "../lib/parse" ->
      parse

provide:
   Repl, kb.Interactor as Interactor, parse, tokenize, eg.Source as Source
   make_cards

globals:
   document, window, alert, jQuery, setTimeout, Showdown




gensym = GenSym{"io_"}

;; macro [%]{context, scope, {=> env}, #data{descr, contents}}:

;;    tag = .div
;;    cls = {}
;;    id = null
;;    kv = '{=}

;;    parse{match whole} =
;;       #void{} -> null
;;       #symbol{s} ->
;;          tag := s
;;       #value{x} ->
;;          cls.push with x
;;       '[. ^[#symbol{x} or #value{x}]] ->
;;          cls.push with x
;;       '[# ^[#symbol{x} or #value{x}]] ->
;;          id := #value{x}
;;       '[^_ = ^_] ->
;;          kv.push with whole
;;       #send{expr, rest} ->
;;          parse{expr}, parse{rest}
;;       #multi{*args} or #data{*args} ->
;;          args each arg -> parse{arg}

;;    parse{descr}

;;    if id:
;;       kv.push with '["id" = ^id]
;;    if cls.length:
;;       kv.push with '["className" = ^=cls.join{" "}]

;;    contents ?=
;;       #void{} -> #array{}
;;       #multi{*args} ->
;;          xs = {}
;;          args each
;;             pair and '[^k = ^v] ->
;;                kv.push with pair
;;             splice and '[** ^_] ->
;;                kv.push with splice
;;             other ->
;;                xs.push with other
;;          #array{*xs}
;;       pair and '[^k = ^v] ->
;;          kv.push with pair
;;          #array{}
;;       x -> x

;;    '[^env.convert{'create_node}]{^=tag, ^kv, ^contents}


create_node{tag, kv, contents} =
   node = document.createElement{tag}
   items{kv} each {k, v} ->
      node[k] := v
   [Array! contents] each
      String? s ->
         node.appendChild{document.createTextNode{s}}
      other ->
         node.appendChild{other}
   node


make_dom{match, default_tag = "div"} =

   String? s ->
      document.createTextNode{s}

   Array? args ->
      node = document.createElement{"span"}
      args each arg ->
         node.appendChild{make_dom{arg, default_tag}}
      node

   Node? {=> classes, => children} ->
      tag = default_tag
      _classes = {}
      id = null
      kv = {}
      sub = {}
      classes each
         #assoc{k, v} ->
            kv.push with {k, v}
         #assoc{k} ->
            kv.push with {k, undefined}
         R'[start, "+", {*any}]! {_, m} ->
            tag := m
         R'[start, "#", {*any}]! {_, m} ->
            id := m
         String? s ->
            _classes.push with s

      node = document.createElement{tag}
      if id:
         node.id := id
      if _classes.length:
         node.className := _classes.join{" "}
      kv each {k, v} ->
         node[k] := v

      match tag:
         .raw ->
            children each
               String? s ->
                  node.innerHTML := s
         other ->
            children each c ->
               node.appendChild{make_dom{c, default_tag}}

      node

   other ->
      make_dom{String! other}

mktable{x, recur = repr} =
   its = match x:
      Array? -> x
      other -> items{x}
   if its.length:
      then:
         table.object %
            its each {k, v} ->
               tr %
                  th % recur{k, repr}
                  td % recur{v, repr}
      else:
         .object.empty %

mktable2{x, recur = repr} =
   its = match x:
      Array? -> x
      other -> items{x}
   table %
      its each {k, v} ->
         tr %
            th % recur{k, repr}
            td % recur{v, repr}

repr{match x, Function? recur = repr} =
   === true -> .special.true % "true"
   === false -> .special.false % "false"
   null? -> .special.nil % "null"
   undefined? -> .special.nil % "undefined"
   Number? -> .num % String{x}
   "" -> .str.empty %
   String? -> .str % x
   Array? {} -> .sequence.empty %
   Array? entries ->
      .sequence % [entries each x -> recur{x, repr}]
   Node? n ->
      n
   when x["::repr"] ->
      x["::repr"]{recur}
   when Object.getPrototypeOf{x} === Object.prototype ->
      mktable{x}
   when x.constructor and x.constructor["::egclass"] ->
      .instance %
         .classname % x.constructor["::name"]
         mktable{x}
   when x["::egclass"] ->
      .class %
         .classname % "Class " + x["::name"]
         mktable{x.prototype}
   Function? f ->
      .function % if{f.name, f.name, "<anonymous>"}
   other ->
      .unknown % other.toString{}


goto_end{elem} =
   let range = document.createRange{}
   range.selectNodeContents{elem}
   range.collapse{false}
   selection = window.getSelection{}
   selection.removeAllRanges{}
   selection.addRange{range}

insert_before_caret{text} =
   node = match text:
      String? -> document.createTextNode{text}
      other -> other
   sel = window.getSelection{}
   if sel.rangeCount:
      let range = sel.getRangeAt{0}
      using range:
         @collapse{false}
         @insertNode{node}
      range := range.cloneRange{}
      using range:
         @selectNodeContents{node}
         @collapse{false}
      sel.removeAllRanges{}
      sel.addRange{range}


Error.prototype["::repr"] := {} ->
   format_error{this}


class Repl:

   constructor{box, target, input, evaluator} =

      @url := "<repl>"
      @gen := eg.Generator{true}
      @evaluator := evaluator

      @box := box
      @target := target
      @input := input
      @multiline := false

      @interactor := kb.Interactor{{=}}
      @set_multiline{false}
      @interactor.install{@input}

      @cursor := 0
      @history := {""}

   sink{} =
      jQuery{@box}.scrollTop{@box.scrollHeight}

   add_to_history{text} =
      hl = @history.length
      if [text !== "" and not [hl > 1 and @history[hl - 2] == text]]:
         ;; Only add to history if the command was nonempty
         ;; and we're not repeating the same command
         @history[hl - 1] := text
         @history.push{""}
      @cursor := @history.length - 1

   submit{} =
      @set_multiline{false}
      text = @input.textContent
      @process{text}
      @input.innerHTML := ""
      @sink{}

   begin_multiline{} =
      @set_multiline{true}
      ;; @input.innerHTML := @input.innerHTML + "\n   "
      goto_end{@input}
      insert_before_caret{"\n   "}
      @sink{}

   set_multiline{x} = match x:
      do:
         previous{} =
            if [@cursor > 0]:
               @input.textContent := @history[-- @cursor]
               goto_end{@input}
               @sink{}
         next{} =
            if [@cursor < @history.length - 1]:
               @input.textContent := @history[++ @cursor]
               goto_end{@input}
               @sink{}
         common = {
            "C-l"{} =
               jQuery{@target}.empty{}
            "S-Enter"{} =
               @submit{}
         }

      === false ->
         jQuery{@input}.removeClass{.multiline}
         @interactor.set_bindings with common & {
            "C-m"{} =
               @set_multiline{true}
               .break
            "C-Enter"{} =
               @begin_multiline{}
               .break
            Enter{} =
               match @input.textContent:
                  R"(=|->|%|:|with|where|each)$"? ->
                     @begin_multiline{}
                  other ->
                     @submit{}
            Up = previous
            Down = next
         }

      === true ->
         jQuery{@input}.addClass{.multiline}
         @interactor.set_bindings with common & {
            "C-m"{} =
               @set_multiline{false}
               .break
            "C-Enter"{} =
               @submit{}
            Enter{} =
               insert_before_caret{"\n"}
               @sink{}
            Tab{} =
               insert_before_caret{"   "}
         }

   generate{text} =
      @gen.generate{eg.Source{text, @url}}

   eval{text} =
      [gen{} !! e -> handle{e}] where
         gen{} =
            g = @generate{text}
            #success{@evaluator{g}}
         handle{e} =
            #failure{e}

   process{text, display_in = true} =
      @add_to_history{text}
      real_text = "\n" + text + "\n"
      node = make_dom with
         .io %
            if display_in:
               then:
                  .[in] %
                     .inbanner %
                     .entry % text or " "
               else:
                  ""
            match @eval{real_text}:
               when text and text.trim{} === "" ->
                  ""
               #success{undefined?} ->
                  ""
               #success{Node? n} ->
                  .display %
                     .displaybanner %
                     .result % n
               #success{value} ->
                  .out %
                     .outbanner %
                     .result % .eg % repr{value}
               #failure{error} ->
                  .err %
                     .errbanner %
                     .result % .eg % repr{error}

      name = gensym{}
      node.id := name

      @target.appendChild{node}

      collapse{e} =
         e.stopPropagation{}
         at_top = @box.scrollTop + jQuery{@box}.height{} == @box.scrollHeight
         jQuery{this}.toggleClass{"collapsed"}
         if at_top:
            jQuery{@box}.scrollTop{@box.scrollHeight}

      on{sel} =
         jQuery{"#" + name + " " + sel}

      on{".sequence"}.addClass{"complex"}
      on{".object"}.addClass{"complex"}
      
      on{".complex"}.click{collapse}
      on{".complex .complex .complex"}.addClass{.collapsed}

      on{".error_args.syntax"}.addClass{.collapsed}.click{collapse}
      on{".traceback"}.addClass{.collapsed}.click{collapse}



make_cards{repl} =

   clickable{text} =
      click{e} =
         e.preventDefault{}
         repl.process{text}
         repl.sink{}
         jQuery{repl.input}.focus{}
      .clickable [onclick = click] %
         text

   clickable_row{*items} =
      span %
         items each
            first item ->
               clickable{item}
            item ->
               span % [span.separator % "", clickable{item}]

   {

      .card %
         h3 % "Keyboard controls"
         mktable2{{...}} with
            {code % "Up/Down", "Navigate history"}
            {code % "Enter/Shift-Enter", "Evaluate an expression"}
            {code % "Control-l", "Clear the screen"}
            {code % "Control-m", "Toggle mulitline mode"}
         "Type ", clickable{"next"}, " to continue with the tutorial"
      
      .card %
         h3 % "Basics"
         % | "Click on boxes like ", clickable{"this"}
           | " to evaluate their contents."
         h4 % "Strings"
         span % clickable_row with
            "\"hello world\""
            ".word"
            "\"My name is \\\"Olivier\\\"\""
         h4 % "Numbers"
         mktable2{{...}} with
            with | % "Decimal"
                 | clickable_row{"1", "1.4", "4.93e51"}
            with | % "Hex"
                 | clickable_row{"16rFF", "16r100", "16rDEADBEEF", "16r0.8"}
            with | % "Binary etc."
                 | clickable_row{"2r1110", "3r20", "36rZAZZ"}
         h4 % "Function calls"
         mktable2{{...}} with
            with | % "Call"
                 | clickable_row{"alert{\"Hello!\"}", "alert with \"Hello!\""}
            with | % "Methods"
                 | clickable_row{"\"hello\".substring{1}"}
         
         clickable{"next"}, " => variables"

      .card %
         h3 % "Variables"
         % | "There are separate operators for declaration and assignment. "
           | "A variable cannot be assigned to before it is declared."
         table %
            tr %
               td % [b % "Declare", " a variable"]
               td % clickable{"x = 1234"}
            tr %
               td % [b % "Set", " an existing variable"]
               td % clickable{"x := 999"}
            tr %
               td % [b % "Use", " your variable!"]
               td % clickable{"x + x"}
         % | "You can create blocks with their own local variables using ",
           | code%"[]", ", ", code%"let", " or ", code%"where"
         % clickable{"[a = 10, b = 90, a + b]"}
         % clickable{"let [a = 10, b = 90]: a + b"}
         % clickable{"a + b where
   a = 10
   b = 90"}
         % | "Be aware that ", code%"[]", " only creates a block"
           | " when it encloses more than one expression."
         % | "An indented block is completely equivalent to "
           | "wrapping it in ", code%"[]", "s"
         clickable{"next"}, " => data structures"

      .card %
         h3 % "Data structures"
         % | "Earl Grey uses curly braces "
           | [code % "{}"], " to define all data structures."
         mktable2{{...}} with
            with | % "Arrays"
                 | clickable_row{"{1, 2, 3}", "{1, {2, 3}}", "{\"hello\"}"}
            with | % "Objects"
                 | clickable_row{"{name = .Peter, age = 20}", "{\"a\" => 123}"}
         % | "The empty array is ", clickable{"{}"}
           | " and the empty object is ", clickable{"{=}"}
         h4 % "Deconstruction"
         % "You can extract array elements and object fields into variables directly."
         % clickable{"{x, y} = {11, 22}"}
         % clickable{"{x, *rest, y} = {111, 222, 333, 444}"}
         % clickable{"{=> name} = {name = .Peter, age = 20}"}
         h4 % "Operations"
         mktable2{{...}} with
            with | % "Concatenation"
                 | clickable{"{1, 2} ++ {3, 4, 5}"}
            with | % "Object fusion"
                 | clickable{"{name = .Kim} & {age = 39}"}
         clickable{"next"}, " => control structures"

      .card %
         h3 % "Control structures"
         % | code % "if", " and ", code % "while"
           | " are available."
         % clickable{"if [13 > 0]:
   then: \"This number is positive!\"
   else: \"This number is negative!\"
"}
         % clickable{"i = 3
while [i > 0]:
   alert{i}
   i--
"}
         % | "Notice that both branches of ", code % "if", " must be nested."
           | " The expression form of ", code % "if", " is simply "
           | clickable{"if{1, .yes, .no}"}
         clickable{"next"}, " => control structures [2]"

      .card %
         h3 % "Control structures [2]"
         % | "Earl Grey's ", code%"if", " nests poorly, so if you want to "
           | "write many clauses use ", code%"match"
         % clickable{"x = 13
match:
   when x > 0 -> .positive
   when x < 0 -> .negative
   when x == 0 -> .zero
"}
         % "You can also match on the variable directly!"
         % clickable{"x = 13
match x:
   > 0 -> .positive
   < 0 -> .negative
   0 -> .zero
"}
         % | "The left hand side of the arrow is a special pattern matching"
           | " language, whereas ", code%"when", " takes a standard expression."

         clickable{"next"}, " => each"


      .card %
         h3 % "each"
         % | "A single operator serves both looping over data structures"
           | " and list comprehensions."
         % clickable{"{1, 2, 3} each i -> -i"}
         % clickable{"1..10 each i -> i * i"}
         % clickable{"1..10 each i when i mod 2 == 0 -> i"}
         % | "You can have more than one clause"
         % clickable{"{1, 2, .hello, 4, 72, 99, {}} each
   String? s -> {s, .string}
   Number? i when i mod 2 == 0 -> {i, .even}
   Number? i when i mod 2 == 1 -> {i, .odd}
   x -> {x, .dunno}
"}
         % | code%"first", " and ", code%"last", " are special patterns"
         % clickable{"acc = \"\"
{.a, .b, .c, .d} each
   first x -> acc += \"[\" + x
   last x -> acc += \", \" + x + \"]\"
   x -> acc += \", \" + x
acc
"}
         % "Be careful to put the catchall clause last."
         clickable{"next"}, " => functions"

      .card %
         h3 % "Functions"
         % | "Functions are declared with ", code%"=", " or ", code%"->"
           | ". For instance the following are equivalent"
         % clickable{"f{x, y} = [x * x + y * y] ** 0.5"}
         % clickable{"f = {x, y} -> [x * x + y * y] ** 0.5"}

         % | "It works inside object definitions as well, of course"
         % clickable{"{add1{x} = x + 1, add2{x} = x + 2}"}

         % | "Pattern matching is deeply integrated in Earl Grey. "
           | "For instance:"
         % clickable{"fact{match} =
   0 or 1 -> 1
   n -> n * fact{n - 1}
"}

         clickable{"next"}, " => type checking and coercion"

      .card %
         h3 % "Type checking and coercion"
         mktable2{{...}} with
            with | % "Type checking"
                 | clickable_row{"String? .hello", "Number? 1", "Array? .nope", "R\"x$\"? .simplex"}
            with | % "Coercion"
                 | clickable_row{"String! {1, 2}", "Number! \"3.14\"", "Array! .yep"}

         % | "Both type checking and coercion can be used in patterns."
           | " Observe the difference in behavior of the following functions "
           | " (try on ", clickable{"f{1, \"2\"}"}, ")"
         % clickable{"f{x, y} = x + y"}
         % clickable{"f{Number? x, Number? y} = x + y"}
         % clickable{"f{Number! x, Number! y} = x + y"}

         % | "Functions naturally act as coercers: "
           | clickable{"parseInt! x = \"99\""}

         h4 % "Predicates"
         % | "You can create your own predicates with the "
           | code%"predicate", " builtin"
         % clickable{"predicate! even{x} = x mod 2 == 0"}
         % clickable_row{"even? x = 1", "even? x = 2"}

         clickable{"next"}, " => classes"

      .card %
         h3 % "Classes"
         % | "Classes are declared with the ", code%"class"
           | " macro. As a convenience, @ can be used to"
           | " refer to fields and members of the instance."
         % clickable{"class Person:
   constructor{name, age, job} =
      @name := name
      @age := age
      @job := job
   hello{} =
      \"Hello, I am \" + @name + \", \" + @age + \", and I am a \" + @job
"}
         % | "The ", code%"new", " keyword is optional."
           | " I prefer to avoid it."
         % clickable{"Person{.Sonia, 25, .baker}"}
         % clickable{"Person{.Jack, 56, \"serial murderer\"}.hello{}"}
         clickable{"next"}, " => HTML generation"

      .card %
         h3 % "Here, let's have some fun"
         % | "The ", code%"%", " operator creates structured data"
           | " which is directly translated as HTML."
         % clickable_row{"b % .hello", "i % .hello"}
         % "We can print out a multiplication table!"
         % clickable_row{"table % 1..10 each i ->
   tr % 1..10 each j ->
      td % i * j
"}

      .card %
         h3 % "The end"
         % | "This is the end of this humble tutorial,"
           | " but you can keep messing around with the language,"
           | " it's a lot of fun :)"

   }
