
require:
   "earl-grey" as eg
   "earl-grey/lib/location" ->
      Location, highlight_locations
      format_error
   "earl-grey/lib/lex" ->
      tokenize
   "earl-grey/lib/parse" ->
      parse
   quaint
   codemirror as CodeMirror
   "codemirror/addon/runmode/runmode"
   "./earlmode"
   "./repl" ->
      Repl, Nav
   "./util" ->
      DOM, repr
   "./doc" ->
      card_displayer as __card_displayer
      __insert_doc


provide:
   Repl
   parse, tokenize, eg.Source as Source
   setup

globals:
   document, window, alert, jQuery, setTimeout
   Element

macros:
   require: "./doc" -> acquire_cards
   {acquire_cards = acquire_cards}


__cards = {=}
card_displayer = __card_displayer{__cards}

do:
   raw = acquire_cards with
      "basic.q"
      "examples.q"
      "advanced.q"
   Q = quaint.Engine{quaint.dispatch}
   __cards &: object with raw each {topic, description, text} ->
      qdesc = Q.run{description}
      {topic, {qdesc, card_displayer{topic, description, text}}}

   __cards.index = {"Index"} with {repl, tab} ->
      repl.nav.insert_page{tab, -1, .index} with
         .card % .blocks %
            h2 % .Index
            table %
               items{__cards}.sort{} each {topic, {desc, f}} ->
                  tr %
                     td % __insert_doc{__cards, repl, tab, topic}
                     td % desc
      undefined




setup{} =

   gen = eg.Generator{true}

   __eval = eval

   repl = Repl with
      document.getElementById{"box"}
      document.getElementById{"interactive"}
      document.getElementById{"code"}
      {text} ->
         try:
            g = gen.generate{eg.Source{text, "<repl>"}}
            #success{__eval{g}}
            e -> #failure{e}
      {...} with
         ;; smart parentheses
         "'('"{cm} =
            cur = cm.getCursor{}
            tok = cm.getTokenAt{cur}
            situation =
               match tok.type:
                  .string when tok.end > cur.ch ->
                     .string
                  .string when R"\"$"? tok.string or R"^\."? tok.string ->
                     .id
                  .string ->
                     .string
                  .operator or .wordop or .open or .punctuation or === null ->
                     .op
                  else ->
                     .id
            match situation:
               .string -> CodeMirror.Pass
               .op -> cm.replaceSelection{"["}
               .id -> cm.replaceSelection{"{"}

         "')'"{cm} =
            cur = cm.getCursor{}
            tok = cm.getTokenAt{cur}
            situation =
               match tok.type:
                  .string when tok.end > cur.ch ->
                     .string
                  .string when R"\"$"? tok.string or R"^\."? tok.string ->
                     .other
                  .string ->
                     .string
                  else ->
                     .other
            match situation:
               .string -> CodeMirror.Pass
               else ->
                  match tok.state.nest:
                     {*, {match, *}} ->
                        "{" -> cm.replaceSelection{"}"}
                        "[" -> cm.replaceSelection{"]"}
                        else -> CodeMirror.Pass
                     else ->
                        CodeMirror.Pass


   repl.nav = Nav{document.getElementById{"help"}}

   ;; {window._cards, engine} = make_cards{repl}

   engine = quaint.Engine{quaint.dispatch}

   window.__qengine = engine
   window.__cards = __cards
   window.__repl = repl
   window.DOM = DOM
   window.$io = {}
   window.$current = -1
   window.$libs = {=}
   window.__eval = __eval

   repl.eval with S[

      globals:
         __cards, alert, document
         window, _current, _next, _help
         __qengine, repl, __repl
         DOM
         $io, $current, $libs
         setInterval, clearInterval

      var _current = -1

      _next{} =
         "There is no tutorial yet."

      _help{match topic} =
         when __cards[topic] ->
            __cards[topic][1]{__repl, 0}
         else ->
            "Invalid help topic: \"" + topic + "\""

      macro next{_, _, form, _}:
         '[^form.env.mark{'_next}]{}

      macro help{_, _, form, match}:
         do: h = form.env.mark{'_help}
         #void{} -> '[^h]{"help"}
         topic -> '[^h]{^topic}

      macro Q{_, _, _, arg}:
         '__qengine.run{^arg}

      loader{url, fn} =
         script = DOM with script %
            async = true
            src = url
            type = "text/javascript"
            onload = fn
         document.head.appendChild{script}
         undefined

      macro load{*, '[^url as ^v]}:
         '[
            splice:
               globals: ^v
               [
                  url = ^url
                  if $libs[url]:
                     then:
                        $out.log with .note %
                           "\"" + url + "\" is already loaded."
                     else:
                        $libs[url] = true
                        __repl.lock{}
                        timer = setTimeout{f, 2000} where f{} =
                           $out.log with .warning %
                              "Loading \"" + url + "\" is taking more than 2 seconds."
                              "A green box will appear here once if/when it is loaded."
                           __repl.unlock{}
                           $libs[url] = false
                        loader{url} with {} ->
                           $out.log with .success %
                              "Loaded \"" + url + "\"!"
                           __repl.unlock{}
                           clearTimeout{timer}
               ]
         ]

      macro $out{*, match}:
         do:
            globals: $current
         #void{} ->
            '$io[^=$current]
         expr ->
            '$io[^=$current][^expr]
   ]

   repl.process{"help", false}

   repl.cm.focus{}

   repl



