
require:
   opg ->
      Location, Source
   "opg/lib/highlight" ->
      highlightLocations
   fs
   jquery

provide:
   DOM, dom_node_clear, mktable, myrepr as repr
   GenSym, format_error, wait

globals:
   document, window, alert, setTimeout
   Element


wait = promisify with {d, f} -> setTimeout.call{null, f, d}


tag_namespaces = {=}
[tags each tag -> tag_namespaces[tag] = "http://www.w3.org/2000/svg"] where
   tags = {
      .svg
      .circle, .line, .path, .rect, .text, .g
   }


wrapChildren{tag, attrs, var children} =
   children = children each c ->
      wrapper = document.createElement{.span}
      wrapper.appendChild{c}
      if c.className:
         wrapper.className = [c.className.split{" "} each x -> S'container-{x}'].join{" "}
      wrapper
   {tag, attrs, children}

preWrappers = {
   assoc = wrapChildren
   array = wrapChildren
}

collapsible{collapsed}{result, opts} =
   result.onclick{e} =
      e.stopPropagation{}
      [opts.wrapchange or [f -> f{}]] with
         -> jquery{result}.toggleClass{"collapsed"}
   if collapsed:
      result.className += " collapsed"
   result

postWrappers = {
   array = collapsible{false}
   object = collapsible{false}
   instance = collapsible{false}
   class = collapsible{false}
   traceback = collapsible{true}
   error_args = collapsible{true}
}


;; wrapChildren = {
;;    assoc = true
;;    array = true
;; }

;; collapsible = {
;;    array = true
;;    object = true
;;    instance = true
;;    class = true
;;    traceback = "collapsed"
;;    error_args = "collapsed"
;; }


toDOM = ENode.getHTMLConverter{.dom}

wrapNode{c} =
   wrapper = document.createElement{.span}
   wrapper.appendChild{c}
   if c.className:
      wrapper.className = [c.className.split{" "} each x -> S'container-{x}'].join{" "}
   wrapper

DOM{match x, opts = {=}} =
   Element? e ->
      e
   Array? args ->
      DOM{% args, opts}
   ENode? e ->

      e.toHTML with {match _tag, _attrs, _children, orig} ->

         do:
            var {tag, attrs, children} = {_tag, _attrs, _children}

         .delayed ->
            var expanded = false
            fn = attrs.compute
            get node = DOM{elem, opts} where elem =
               span.collapsed %
                  onclick{e} =
                     e.stopPropagation{}
                     if not expanded:
                        delete node.onclick
                        expanded = true
                        node.className = ""
                        [opts.wrapchange or [f -> f{}]] with
                           -> node.appendChild{DOM{fn{}, opts}}

         else ->

            [if{attrs, attrs.class or "", ""}].split{" "} each
               c when preWrappers[c] ->
                  {tag, attrs, children} =
                     preWrappers[c]{tag, attrs, children, orig, opts}

            ;; if attrs and [attrs.class or ""].split{" "}.some{x -> wrapChildren[x]}:
            ;;    children = children each c -> wrapNode{c}

            if [ns = tag_namespaces[String! tag]]:
               attrs = attrs & {namespace = ns}

            var result = toDOM{tag, attrs, children}

            ;; [attrs and attrs.class or ""].split{" "} each
            ;;    x when collapsible[x] ->
            ;;       result.onclick{e} =
            ;;          e.stopPropagation{}
            ;;          [opts.wrapchange or [f -> f{}]] with
            ;;             -> jquery{result}.toggleClass{"collapsed"}
            ;;       if collapsible[x] === "collapsed":
            ;;          result.className += " collapsed"

            [if{attrs, attrs.class or "", ""}].split{" "} each
               c when postWrappers[c] ->
                  result = postWrappers[c]{result, opts}

            if attrs and attrs._refid:
               DOM with
                  ".tagged-node" %
                     .reference % attrs._refid
                     result

            elif attrs and ENode? orig:
               ;; This is a dirty hack to display a reference number
               ;; when it is added later by a delayed calculation.
               ;; That number will be written in props._refid, so we
               ;; watch for changes.
               var _theid = undefined
               Object.defineProperty{orig.props, "_refid"} with {
                  configurable = true
                  .get{} = _theid
                  .set{v} =
                     _theid = v
                     wrapper = DOM with
                        ".tagged-node" %
                           .reference % _theid
                     result.parentElement.replaceChild{wrapper, result}
                     wrapper.appendChild{result}
               }
               result

            else:
               result

   else ->
      DOM{% x, opts}


   ;; DOM{match x, default_tag = "span"} =

   ;; String? s or Number? s ->
   ;;    document.createTextNode{String{s}}

   ;; Element? e ->
   ;;    e

   ;; Array? args ->
   ;;    node = document.createElement{"span"}
   ;;    args each arg ->
   ;;       node.appendChild{DOM{arg, default_tag}}
   ;;    node

   ;; ENode? {=> tags, => props, => children} ->
   ;;    var tag = default_tag
   ;;    var id = null
   ;;    classes = {}
   ;;    tags each
   ;;       R"^#(.*)"! {_, name} ->
   ;;          id = name
   ;;       R"^\.(.*)"! {_, name} ->
   ;;          classes.push{name}
   ;;       other ->
   ;;          tag = other

   ;;    var node = match tag_namespaces[tag]:
   ;;       undefined? ->
   ;;          document.createElement{tag}
   ;;       ns ->
   ;;          document.createElementNS{ns, tag}

   ;;    if id:
   ;;       node.id = id

   ;;    if classes.length:
   ;;       node.className = classes.join{" "}
   ;;    items{props} each {match k, v} ->
   ;;       R"^on"? ->
   ;;          node[k] = v
   ;;       else ->
   ;;          node.setAttribute{k, v}

   ;;    match tag:
   ;;       .raw ->
   ;;          tag = .span
   ;;          match children:
   ;;             {String? s} ->
   ;;                node.innerHTML = s
   ;;       when classes.some{{c} -> wrapChildren[c]} ->
   ;;          children each c ->
   ;;             wrapper = document.createElement{.span}
   ;;             wrapper.appendChild{DOM{c, default_tag}}
   ;;             node.appendChild{wrapper}
   ;;       other ->
   ;;          children each c ->
   ;;             node.appendChild{DOM{c, default_tag}}

   ;;    node

   ;; other ->
   ;;    ;; print {other, Number? other, String? other, typeof{other}}
   ;;    DOM{repr{other}}
   ;;    ;; DOM{String{other}}


wrapRepr{match x, process} =

   not [{"::lightweight" => lw} when lw{}] when process.repr.depth >= 3 ->
      delayed %
         compute{} = process.repr.withState{{depth = 0}}{x}

   Array? and {ast => true?} ->
      astrepr{x} where astrepr{match node} =
         #void{} ->
            .ast.void %
         #symbol{x} ->
            .ast.symbol % process.repr{x}
         #value{x} ->
            .ast.value % process.repr{x}
         #send{f and #symbol{match}, arg and #data{x, y}} ->
            "." when y[0] === .symbol ->
               .ast.value % process.repr{y[1]}
            when node.fromop ->
               .ast.oper %
                  .ast.buffer % astrepr{x}
                  .ast.buffer % astrepr{f}
                  .ast.buffer % astrepr{y}
            else ->
               .ast.send %
                  .ast.buffer % astrepr{f}
                  .ast.buffer % astrepr{arg}
         {kind in {.send, .data, .multi}, *args} ->
            .ast[^["." + kind]] % args each arg -> .ast.buffer % astrepr{arg}
         else ->
            process{node}

   else ->
      process{x}

myrepr{x, wrap = null} =
   r = repr.create{{wrap = wrap or wrapRepr}}
   result = r{x}
   r.seen
   result

;; myrepr{x, state = {depth = 0, seen = new Map{}, preprocess = preproc, repr = repr}} =
;;    repr{x, state}

;; myrepr{match x, state = {depth = 0, seen = new Map{}, repr = repr}} =
;;    Array? and {ast => true?} ->
;;       astrepr{x} where astrepr{match node} =
;;          #void{} ->
;;             .ast.void %
;;          #symbol{x} ->
;;             .ast.symbol % x
;;          #value{x} ->
;;             .ast.value % state.repr{x, state & {repr = myrepr}}
;;          #send{f and #symbol{match}, arg and #data{x, y}} ->
;;             "." when y[0] === .symbol ->
;;                .ast.value % state.repr{y[1], state & {repr = myrepr}}
;;             when node.fromop ->
;;                .ast.oper %
;;                   .ast.buffer % astrepr{x}
;;                   .ast.buffer % astrepr{f}
;;                   .ast.buffer % astrepr{y}
;;             else ->
;;                .ast.send %
;;                   .ast.buffer % astrepr{f}
;;                   .ast.buffer % astrepr{arg}
;;          {kind in {.send, .data, .multi}, *args} ->
;;             .ast[^["." + kind]] % args each arg -> .ast.buffer % astrepr{arg}
;;          else ->
;;             state.repr{node, state & {repr = myrepr}}
;;    else ->
;;       state.repr{x, state & {repr = myrepr}}





mktable{x, recur = repr} =
   null
   ;; its = match x:
   ;;    Array? -> x
   ;;    other -> items{x}
   ;; if its.length:
   ;;    then:
   ;;       table.object %
   ;;          its each {k, v} ->
   ;;             tr %
   ;;                th % recur{k, repr}
   ;;                td % recur{v, repr}
   ;;    else:
   ;;       div.object.empty %


;; let repr{match x, Function? recur = repr} =
;;    === true -> div.special.true % "true"
;;    === false -> div.special.false % "false"
;;    null? -> div.special.nil % "null"
;;    undefined? -> div.special.nil % "undefined"
;;    Number? -> div.num % String{x}
;;    "" -> div.str.empty %
;;    String? -> div.str % x
;;    Array? {} -> div.sequence.empty %
;;    Array? entries ->
;;       div.sequence % [entries each x -> recur{x, repr}]
;;    ENode? n ->
;;       n
;;    Element? e ->
;;       e
;;    when x[":::repr"] ->
;;       x[":::repr"]{recur}
;;    when Object.getPrototypeOf{x} === Object.prototype ->
;;       mktable{x}
;;    when x.constructor and x.constructor["::egclass"] ->
;;       div.instance %
;;          div.classname % x.constructor["::name"]
;;          mktable{x}
;;    when x["::egclass"] ->
;;       div.class %
;;          div.classname % "Class " + x["::name"]
;;          mktable{x.prototype}
;;    Function? f ->
;;       .function % if{f.name, f.name, "<anonymous>"}
;;    other ->
;;       .unknown % other.toString{}



dom_node_clear{x} =
   while x.children.length > 0:
      x.removeChild{x.children[0]}


format_error{match e, context = 0} =

   do:
      fmt_args{e} =
         if [e.args and e.args.length]:
            then: .error_args % repr{e.args}
            else: ""

   E.syntax? {args => {args}} ->
      hls = {.hl1, .hl2, .hl3, .hl4}
      locs = enumerate{items{args}} each
         {i, {key, arg}} when arg and arg.location ->
            {arg.location, hls[i mod 4]}
      div %
         div.error %
            div.error_type % e.name
            div.error_message % e.message
         div.error_args.syntax % repr{args}
         highlightLocations{locs, context}

   {location => loc and {=> source, => start, => end}} ->
      div %
         div.error %
            div.error_type % e.name
            div.error_message % e.message
         fmt_args{e}
         highlightLocations{{{loc, .hl1}}, context}
         div.traceback % e.stack or ""

   {location => #location{url, start, end}} ->
      data = fs.readFileSync{url, .utf8} !! e -> null
      if data:
         then:
            loc = Location{Source{data, url}, start, end}
            div %
               div.error %
                  div.error_type % e.name
                  div.error_message % e.message
               fmt_args{e}
               ;; if{e.args, .error_args % repr{e.args}, ""}
               highlightLocations{{{loc, .hl1}}, context}
               div.traceback %
                  div % e.stack or ""
         else:
            div %
               div.error %
                  div.error_type % e.name
                  div.error_message % e.message
               fmt_args{e}
               div.traceback %
                  % e.stack or e

   other ->
      div %
         div.error %
            div.error_type % e.name
            div.error_message % e.message
         ;; if e.args:
         ;;    then: .error_args % repr{e.args}
         ;;    else: ""
         fmt_args{e}
         div.traceback %
            div % e.stack


GenSym{prefix} =
   ;; Simple symbol generator.
   ;; g = GenSym{"$"}
   ;; g{} ==> "$0", "$1", "$2", ...
   ;; g{"xyz"} ==> "xyz$0", "xyz$1", "xyz$2", ...
   id = 0
   {pfx = ""} ->
      r = pfx + prefix + [String! id]
      id++
      r
