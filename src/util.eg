
require:
   opg ->
      Location, Source
   "opg/lib/highlight" ->
      highlightLocations
   fs

provide:
   DOM, dom_node_clear, mktable, repr
   GenSym, format_error

globals:
   document, window, alert, setTimeout
   Element


tag_namespaces = {=}
[{...} each tag -> tag_namespaces[tag] = "http://www.w3.org/2000/svg"] with
   .svg
   .circle, .line, .path, .rect, .text


DOM{match, default_tag = "div"} =

   String? s ->
      document.createTextNode{s}

   Element? e ->
      e

   Array? args ->
      node = document.createElement{"span"}
      args each arg ->
         node.appendChild{DOM{arg, default_tag}}
      node

   ENode? {=> tags, => props, => children} ->
      var tag = default_tag
      var id = null
      classes = {}
      tags each
         R"^#(.*)"! {_, name} ->
            id = name
         R"^\.(.*)"! {_, name} ->
            classes.push{name}
         other ->
            tag = other

      node = match tag_namespaces[tag]:
         undefined? ->
            document.createElement{tag}
         ns ->
            document.createElementNS{ns, tag}

      if id:
         node.id = id

      if classes.length:
         node.className = classes.join{" "}
      items{props} each {match k, v} ->
         R"^on"? ->
            node[k] = v
         else ->
            node.setAttribute{k, v}

      match tag:
         .raw ->
            tag = .span
            match children:
               {String? s} ->
                  node.innerHTML = s
         other ->
            children each c ->
               node.appendChild{DOM{c, default_tag}}

      node

   other ->
      DOM{String! other}


mktable{x, recur = repr} =
   its = match x:
      Array? -> x
      other -> items{x}
   if its.length:
      then:
         table.object %
            its each {k, v} ->
               tr %
                  th % recur{k, repr}
                  td % recur{v, repr}
      else:
         .object.empty %


let repr{match x, Function? recur = repr} =
   === true -> .special.true % "true"
   === false -> .special.false % "false"
   null? -> .special.nil % "null"
   undefined? -> .special.nil % "undefined"
   Number? -> .num % String{x}
   "" -> .str.empty %
   String? -> .str % x
   Array? {} -> .sequence.empty %
   Array? entries ->
      .sequence % [entries each x -> recur{x, repr}]
   ENode? n ->
      n
   Element? e ->
      e
   when x[":::repr"] ->
      x[":::repr"]{recur}
   when Object.getPrototypeOf{x} === Object.prototype ->
      mktable{x}
   when x.constructor and x.constructor["::egclass"] ->
      .instance %
         .classname % x.constructor["::name"]
         mktable{x}
   when x["::egclass"] ->
      .class %
         .classname % "Class " + x["::name"]
         mktable{x.prototype}
   Function? f ->
      .function % if{f.name, f.name, "<anonymous>"}
   other ->
      .unknown % other.toString{}


dom_node_clear{x} =
   while x.children.length > 0:
      x.removeChild{x.children[0]}


format_error{match e, context = 0} =

   do:
      fmt_args{e} =
         if [e.args and e.args.length]:
            then: .error_args % repr{e.args}
            else: ""

   E.syntax? {args => {args}} ->
      hls = {.hl1, .hl2, .hl3, .hl4}
      locs = enumerate{items{args}} each
         {i, {key, arg}} when arg and arg.location ->
            {arg.location, hls[i mod 4]}
      div %
         .error %
            .error_type % e.name
            .error_message % e.message
         .error_args.syntax % repr{args}
         highlightLocations{locs, context}

   {location => loc and {=> source, => start, => end}} ->
      div %
         .error %
            .error_type % e.name
            .error_message % e.message
         fmt_args{e}
         highlightLocations{{{loc, .hl1}}, context}
         .traceback % e.stack or ""

   {location => #location{url, start, end}} ->
      data = fs.readFileSync{url, .utf8} !! e -> null
      if data:
         then:
            loc = Location{Source{data, url}, start, end}
            div %
               .error %
                  .error_type % e.name
                  .error_message % e.message
               fmt_args{e}
               ;; if{e.args, .error_args % repr{e.args}, ""}
               highlightLocations{{{loc, .hl1}}, context}
               .traceback %
                  % e.stack or ""
         else:
            div %
               .error %
                  .error_type % e.name
                  .error_message % e.message
               fmt_args{e}
               .traceback %
                  % e.stack or e

   other ->
      div %
         .error %
            .error_type % e.name
            .error_message % e.message
         ;; if e.args:
         ;;    then: .error_args % repr{e.args}
         ;;    else: ""
         fmt_args{e}
         .traceback %
            % e.stack


GenSym{prefix} =
   ;; Simple symbol generator.
   ;; g = GenSym{"$"}
   ;; g{} ==> "$0", "$1", "$2", ...
   ;; g{"xyz"} ==> "xyz$0", "xyz$1", "xyz$2", ...
   id = 0
   {pfx = ""} ->
      r = pfx + prefix + [String! id]
      id++
      r
